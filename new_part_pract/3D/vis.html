<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Arena 3D –í–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä –ë–æ–µ–≤</title>
  <style>
    :root{
      --bg:#0b0f1a;--bg2:#0e1424;--panel:#121b30;--panel2:#0f1a33;
      --accent:#2dd4bf;--accent2:#8b5cf6;--text:#e5ecff;--muted:#94a3b8;--danger:#ef4444;--ok:#22c55e;--warn:#f59e0b;
      --border:#1f2a44;--chip:#1b2540;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;padding:0;background:linear-gradient(135deg,var(--bg),var(--bg2));color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      overflow:hidden;
    }
    .wrap{display:flex;flex-direction:column;height:100%}
    header{
      padding:14px 18px;border-bottom:1px solid var(--border);
      display:flex;gap:16px;align-items:center;justify-content:space-between;background:linear-gradient(180deg,var(--panel),var(--panel2));
      position:relative;z-index:2;
    }
    header .ttl{display:flex;align-items:center;gap:10px}
    header h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.3px}
    header .sub{font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{
      background:#1a2644;border:1px solid var(--border);color:var(--text);
      padding:8px 12px;border-radius:10px;cursor:pointer;transition:all .15s ease;font-weight:600;
      border:none;outline:none;
    }
    .btn:hover{transform:translateY(-1px);box-shadow:0 4px 14px rgba(0,0,0,.25)}
    .btn.primary{background:linear-gradient(135deg,#1f8a81,#2563eb);border-color:#2563eb}
    .btn.warn{background:#3a2a14;border-color:#7c4a00}
    .btn.ok{background:#11351f;border-color:#1b8a52}
    .btn.danger{background:#381417;border-color:#7a1d27}
    .chip{background:var(--chip);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px}
    .tog{display:flex;align-items:center;gap:8px}
    .tog input{transform:scale(1.2)}
    .speed{display:flex;align-items:center;gap:8px}
    .layout{display:flex;flex:1 1 auto;min-height:0}
    .viewer{position:relative;flex:1 1 auto;min-width:0}
    #threejs-container{position:absolute;inset:0}
    .loading{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      text-align:center;background:rgba(0,0,0,0.8);padding:20px;border-radius:10px;
    }
    .loading .spinner{
      border:3px solid #334155;border-top:3px solid #3b82f6;border-radius:50%;
      width:40px;height:40px;animation:spin 1s linear infinite;margin:0 auto 10px;
    }
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    .overlay-hint{position:absolute;left:50%;top:16px;transform:translateX(-50%);background:#0f172a88;padding:8px 12px;border:1px solid var(--border);border-radius:10px;font-size:12px}
    .debug{position:absolute;top:50px;left:10px;background:rgba(0,0,0,0.8);color:#fff;padding:10px;border-radius:5px;font-size:12px;font-family:monospace}
    .camera-help{position:absolute;bottom:10px;left:10px;background:rgba(0,0,0,0.7);color:#fff;padding:8px;border-radius:5px;font-size:11px;font-family:monospace}
    aside{
      width:320px;max-width:35vw;border-left:1px solid var(--border);background:linear-gradient(180deg,var(--panel),var(--panel2));
      display:flex;flex-direction:column;gap:12px;padding:12px;overflow:auto
    }
    .card{background:#0d142a;border:1px solid var(--border);border-radius:14px;padding:12px}
    .card h3{margin:0 0 6px;font-size:14px;letter-spacing:.3px}
    .row{display:flex;gap:10px}
    .stat{flex:1 1 0;background:#0c1326;border:1px solid var(--border);border-radius:12px;padding:10px;text-align:center}
    .stat .v{font-weight:800;font-size:20px}
    .stat.red{border-color:#7f1d1d}
    .stat.blue{border-color:#1d4ed8}
    .kv{display:flex;justify-content:space-between;padding:4px 0;color:var(--muted);font-size:12px}
    .timeline input[type=range]{width:100%}
    .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .robot-info{min-height:110px;max-height:180px;overflow:auto;font-size:12px}
    .drop{border:2px dashed #334155;border-radius:14px;background:#0b1226;padding:14px;text-align:center;cursor:pointer}
    .drop.drag{background:#0d1530;border-color:#64748b}
    .muted{color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .hidden{display:none !important}
    .error{color:#ef4444;text-align:center;padding:20px}
    .offline-warning{background:#3a2a14;border:1px solid #7c4a00;color:#f59e0b;padding:10px;margin:10px;border-radius:8px;font-size:12px}
    @media (max-width: 1000px){aside{width:280px}}
    @media (max-width: 860px){
      .layout{flex-direction:column}
      aside{width:100%;max-width:none;height:40vh}
      .viewer{height:60vh}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="ttl">
        <div style="font-size:20px">üõ∞Ô∏è</div>
        <div>
          <h1>Arena 3D –í–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä –ë–æ–µ–≤</h1>
          <div class="sub">3D –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—ë–≤ —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –ø–æ–ª—è –∏ —Ä–∞–¥–∏—É—Å–æ–º –ª–∞–∑–µ—Ä–∞</div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å JSON</button>
        <input type="file" id="fileInput" accept=".json" class="hidden"/>

        <button class="btn ok" id="btnPlay">‚ñ∂ –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏</button>
        <button class="btn" id="btnPause">‚è∏ –ü–∞—É–∑–∞</button>
        <button class="btn danger" id="btnReset">‚ü≤ –°–±—Ä–æ—Å</button>

        <span class="speed">
          <span>–°–∫–æ—Ä–æ—Å—Ç—å:</span>
          <input type="range" id="speed" min="0.2" max="3" step="0.1" value="1"/>
          <span id="speedVal" class="chip mono">1.0x</span>
        </span>

        <label class="tog">
          <input type="checkbox" id="toggleTrails" checked/>
          <span>–°–ª–µ–¥—ã</span>
        </label>
        <label class="tog">
          <input type="checkbox" id="toggleBounds" checked/>
          <span>–ì—Ä–∞–Ω–∏—Ü—ã</span>
        </label>
        
        <button class="btn warn" id="btnDebug">üêõ –û—Ç–ª–∞–¥–∫–∞</button>
        <button class="btn" id="btnCreateDemo">üéÆ –î–µ–º–æ</button>
      </div>
    </header>

    <div class="layout">
      <section class="viewer">
        <div id="threejs-container">
          <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>–ó–∞–≥—Ä—É–∑–∫–∞ 3D –¥–≤–∏–∂–∫–∞...</div>
            <div id="loadingStatus" class="muted">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è</div>
          </div>
        </div>
        <div class="overlay-hint muted mono hidden" id="hint">–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª battle_3d_*.json –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ</div>
        <div class="debug hidden" id="debugInfo">
          –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:<br>
          THREE.js: <span id="threeStatus">‚è≥</span><br>
          –°—Ü–µ–Ω–∞: <span id="sceneStatus">‚è≥</span><br>
          –î–∞–Ω–Ω—ã–µ: <span id="dataStatus">‚ùå</span><br>
          –ö–∞–¥—Ä—ã: <span id="framesStatus">0</span><br>
          –¢–µ–∫—É—â–∏–π: <span id="currentStatus">0</span>
        </div>
        <div class="camera-help" id="cameraHelp">
          üñ±Ô∏è –õ–ö–ú: –ø–æ–≤–æ—Ä–æ—Ç ‚Ä¢ üé° –ö–æ–ª–µ—Å–æ: –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ ‚Ä¢ –ü–ö–ú: –ø–∞–Ω–æ—Ä–∞–º–∞
        </div>
      </section>

      <aside>
        <div class="offline-warning" id="offlineWarning" style="display:none">
          ‚ö†Ô∏è –î–ª—è —Ä–∞–±–æ—Ç—ã –±–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ –ø–æ–º–µ—Å—Ç–∏—Ç–µ —Ñ–∞–π–ª—ã three.min.js –∏ OrbitControls.js –≤ —Ç—É –∂–µ –ø–∞–ø–∫—É
        </div>
        
        <div class="card drop" id="dropZone">üìÅ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ 3D battle JSON —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞</div>

        <div class="card">
          <h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—è</h3>
          <div class="row">
            <div class="stat red">
              <div>–ö—Ä–∞—Å–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞</div>
              <div class="v" id="redHP">0</div>
            </div>
            <div class="stat blue">
              <div>–°–∏–Ω—è—è –∫–æ–º–∞–Ω–¥–∞</div>
              <div class="v" id="blueHP">0</div>
            </div>
          </div>
          <div class="row" style="margin-top:8px">
            <div class="stat">
              <div>–ñ–∏–≤—ã—Ö</div>
              <div class="v" id="aliveCount">0</div>
            </div>
            <div class="stat">
              <div>–í—Ä–µ–º—è</div>
              <div class="v" id="battleTime">0—Å</div>
            </div>
          </div>
        </div>

        <div class="card timeline">
          <h3>‚è∞ –í—Ä–µ–º–µ–Ω–Ω–∞—è —à–∫–∞–ª–∞</h3>
          <input type="range" id="frame" min="0" max="0" value="0"/>
          <div class="kv"><span>–ö–∞–¥—Ä: <span id="cur">0</span></span><span>–í—Å–µ–≥–æ: <span id="tot">0</span></span></div>
        </div>

        <div class="card">
          <h3>üì∑ –ö–∞–º–µ—Ä–∞</h3>
          <div class="grid">
            <button class="btn" data-cam="overview">üèüÔ∏è –û–±–∑–æ—Ä</button>
            <button class="btn" data-cam="side">üìê –°–±–æ–∫—É</button>
            <button class="btn" data-cam="top">‚¨áÔ∏è –°–≤–µ—Ä—Ö—É</button>
            <button class="btn" data-cam="follow">üéØ –°–ª–µ–¥–∏—Ç—å</button>
          </div>
          <div class="muted" style="margin-top:8px">
            üñ±Ô∏è –ü–æ–≤–æ—Ä–æ—Ç/–ü—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ ‚Ä¢ ‚§¢ –ü–ö–ú: –ø–∞–Ω–æ—Ä–∞–º–∞
          </div>
        </div>

        <div class="card">
          <h3>ü§ñ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–æ–±–æ—Ç–µ</h3>
          <div id="robotInfo" class="robot-info">–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —Ä–æ–±–æ—Ç—É, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–µ—Ç–∞–ª–∏</div>
        </div>

        <div class="card">
          <h3>üéûÔ∏è –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è</h3>
          <div id="events" class="robot-info">–°–æ–±—ã—Ç–∏–π –ø–æ–∫–∞ –Ω–µ—Ç</div>
        </div>
      </aside>
    </div>
  </div>

  <script>
    window.debugMode = false;
    let loadingElement, loadingStatus;

    function updateLoadingStatus(message) {
      if (loadingStatus) {
        loadingStatus.textContent = message;
      }
      console.log('üì¶', message);
    }

    function loadScript(src, timeout = 8000) {
      return new Promise((resolve, reject) => {
        updateLoadingStatus(`–ó–∞–≥—Ä—É–∑–∫–∞ ${src.split('/').pop()}...`);
        
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        
        const timeoutId = setTimeout(() => {
          reject(new Error(`Timeout loading ${src}`));
        }, timeout);
        
        script.onload = () => {
          clearTimeout(timeoutId);
          resolve();
        };
        
        script.onerror = () => {
          clearTimeout(timeoutId);
          reject(new Error(`Failed to load ${src}`));
        };
        
        document.head.appendChild(script);
      });
    }

    async function loadThreeJS() {
      const localFiles = [
        './three.min.js',
        './js/three.min.js',
        './libs/three.min.js'
      ];

      const localControls = [
        './OrbitControls.js',
        './js/OrbitControls.js', 
        './libs/OrbitControls.js'
      ];

      const threeCDNs = [
        'https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js',
        'https://unpkg.com/three@0.152.2/build/three.min.js',
        'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js'
      ];

      const controlsCDNs = [
        'https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/controls/OrbitControls.js',
        'https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js',
        'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js'
      ];

      const offlineWarning = document.getElementById('offlineWarning');
      
      let threeLoaded = false;
      const allThreeSources = [...localFiles, ...threeCDNs];
      
      for (const src of allThreeSources) {
        try {
          await loadScript(src, 5000);
          if (typeof THREE !== 'undefined') {
            updateLoadingStatus('THREE.js –∑–∞–≥—Ä—É–∂–µ–Ω ‚úÖ');
            threeLoaded = true;
            
            if (threeCDNs.includes(src)) {
              offlineWarning.style.display = 'none';
            } else {
              updateLoadingStatus('–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã');
            }
            break;
          }
        } catch (error) {
          console.warn(`Failed to load THREE.js from ${src}:`, error);
          if (localFiles.includes(src)) {
            offlineWarning.style.display = 'block';
          }
        }
      }

      if (!threeLoaded) {
        throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å THREE.js. –î–ª—è —Ä–∞–±–æ—Ç—ã –±–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ —Å–∫–∞—á–∞–π—Ç–µ three.min.js –≤ –ø–∞–ø–∫—É —Å —Ñ–∞–π–ª–æ–º.');
      }

      let controlsLoaded = false;
      const allControlsSources = [...localControls, ...controlsCDNs];
      
      for (const src of allControlsSources) {
        try {
          await loadScript(src, 5000);
          if (typeof THREE.OrbitControls !== 'undefined') {
            updateLoadingStatus('OrbitControls –∑–∞–≥—Ä—É–∂–µ–Ω ‚úÖ');
            controlsLoaded = true;
            break;
          }
        } catch (error) {
          console.warn(`Failed to load OrbitControls from ${src}:`, error);
        }
      }

      if (!controlsLoaded) {
        updateLoadingStatus('‚ö†Ô∏è OrbitControls –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã - —Å–æ–∑–¥–∞–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ');
        createSimpleControls();
      }

      return { three: threeLoaded, controls: controlsLoaded };
    }

    function createSimpleControls() {
      THREE.OrbitControls = class {
        constructor(camera, domElement) {
          this.object = camera;
          this.domElement = domElement;
          this.target = new THREE.Vector3();
          this.enableDamping = true;
          this.dampingFactor = 0.05;
          this.minDistance = 1;
          this.maxDistance = 1000;
          this.maxPolarAngle = Math.PI;
          this.enabled = true;
          
          this.setupBasicControls();
        }
        
        setupBasicControls() {
          let isDown = false;
          let mouseButton = -1;
          let mouseX = 0, mouseY = 0;
          
          this.domElement.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
              isDown = true;
              mouseButton = e.button;
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
          });
          
          this.domElement.addEventListener('mousemove', (e) => {
            if (isDown) {
              const deltaX = e.clientX - mouseX;
              const deltaY = e.clientY - mouseY;
              
              const spherical = new THREE.Spherical();
              spherical.setFromVector3(this.object.position.clone().sub(this.target));
              spherical.theta -= deltaX * 0.01;
              spherical.phi += deltaY * 0.01;
              spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
              
              this.object.position.setFromSpherical(spherical).add(this.target);
              this.object.lookAt(this.target);
              
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
          });
          
          this.domElement.addEventListener('mouseup', () => {
            isDown = false;
            mouseButton = -1;
          });
          
          this.domElement.addEventListener('wheel', (e) => {
            const scale = e.deltaY > 0 ? 1.1 : 0.9;
            const direction = this.object.position.clone().sub(this.target);
            direction.multiplyScalar(scale);
            this.object.position.copy(this.target).add(direction);
            e.preventDefault();
          });
          
          this.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        update() {}
      };
      console.log('‚úÖ –°–æ–∑–¥–∞–Ω–∞ —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π');
    }

    class Visualizer {
      constructor() {
        console.log('üéÆ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Arena 3D Visualizer...');
        
        this.data = null;
        this.frames = [];
        this.bounds = null;
        this.laser = null;
        this.cur = 0;
        this.isPlay = false;
        this.speed = 1;
        this.showBounds = true;
        this.showTrails = true;
        this.robots = new Map();
        this.trails = new Map();
        this.trailsLines = new Map();
        this.followId = null;

        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.fieldGroup = null;

        this.$ = id => document.getElementById(id);
        
        this.hookUI();
        this.hookFile();
      }

      async initialize() {
        try {
          loadingElement = this.$('loading');
          loadingStatus = this.$('loadingStatus');
          
          updateLoadingStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...');
          
          const { three, controls } = await loadThreeJS();
          
          if (!three) {
            throw new Error('THREE.js –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è');
          }

          updateLoadingStatus('–°–æ–∑–¥–∞–Ω–∏–µ 3D —Å—Ü–µ–Ω—ã...');
          await this.init3D();

          if (loadingElement) {
            loadingElement.style.display = 'none';
          }

          this.$('hint').classList.remove('hidden');
          
          updateLoadingStatus('–ì–æ—Ç–æ–≤–æ ‚úÖ');
          console.log('‚úÖ Visualizer –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
          
        } catch (error) {
          console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
          this.showError('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + error.message);
        }
      }

      showError(message) {
        if (loadingElement) {
          loadingElement.innerHTML = `
            <div class="error">
              <div style="font-size:24px;margin-bottom:10px;">‚ö†Ô∏è</div>
              <div>${message}</div>
              <div style="margin-top:15px;">
                <button onclick="location.reload()" class="btn">üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å</button>
              </div>
              <div style="margin-top:10px;font-size:12px;color:#94a3b8;">
                –î–ª—è —Ä–∞–±–æ—Ç—ã –±–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ –ø–æ–º–µ—Å—Ç–∏—Ç–µ –≤ –ø–∞–ø–∫—É:
                <br>‚Ä¢ three.min.js
                <br>‚Ä¢ OrbitControls.js
              </div>
            </div>
          `;
        }
      }

      hookUI() {
        this.$('btnLoad').onclick = () => this.$('fileInput').click();
        this.$('btnPlay').onclick = () => this.play();
        this.$('btnPause').onclick = () => this.pause();
        this.$('btnReset').onclick = () => this.reset();
        this.$('btnDebug').onclick = () => this.toggleDebug();
        this.$('btnCreateDemo').onclick = () => this.createDemoData();

        this.$('speed').addEventListener('input', e => {
          this.speed = Number(e.target.value) || 1;
          this.$('speedVal').textContent = this.speed.toFixed(1) + 'x';
        });

        this.$('toggleTrails').addEventListener('change', e => {
          this.showTrails = e.target.checked;
          if (!this.showTrails) {
            this.clearTrails();
          }
        });

        this.$('toggleBounds').addEventListener('change', e => {
          this.showBounds = e.target.checked;
          if (this.fieldGroup) {
            this.fieldGroup.visible = this.showBounds;
          }
        });

        this.$('frame').addEventListener('input', e => {
          this.cur = Math.min(this.frames.length - 1, Math.max(0, Number(e.target.value) || 0));
          this.updateFrame(true);
        });

        document.querySelectorAll('[data-cam]').forEach(btn => {
          btn.addEventListener('click', () => this.setCam(btn.dataset.cam));
        });
      }

      toggleDebug() {
        window.debugMode = !window.debugMode;
        const debug = this.$('debugInfo');
        if (window.debugMode) {
          debug.classList.remove('hidden');
          this.updateDebugStatus();
          setInterval(() => this.updateDebugStatus(), 1000);
        } else {
          debug.classList.add('hidden');
        }
      }

      updateDebugStatus() {
        if (!window.debugMode) return;
        
        this.$('threeStatus').textContent = typeof THREE !== 'undefined' ? '‚úÖ' : '‚ùå';
        this.$('sceneStatus').textContent = this.scene ? '‚úÖ' : '‚ùå';
        this.$('dataStatus').textContent = this.data ? '‚úÖ' : '‚ùå';
        this.$('framesStatus').textContent = this.frames.length;
        this.$('currentStatus').textContent = this.cur;
      }

      hookFile() {
        const input = this.$('fileInput');
        const drop = this.$('dropZone');

        input.onchange = e => {
          if (e.target.files && e.target.files[0]) {
            console.log('üìÅ –§–∞–π–ª –≤—ã–±—Ä–∞–Ω:', e.target.files[0].name);
            this.loadFile(e.target.files[0]);
          }
        };

        drop.addEventListener('click', () => input.click());
        drop.addEventListener('dragover', e => {
          e.preventDefault();
          drop.classList.add('drag');
        });
        drop.addEventListener('dragleave', () => drop.classList.remove('drag'));
        drop.addEventListener('drop', e => {
          e.preventDefault();
          drop.classList.remove('drag');
          const file = e.dataTransfer.files && e.dataTransfer.files[0];
          if (file) {
            console.log('üìÅ –§–∞–π–ª –ø–µ—Ä–µ—Ç–∞—â–µ–Ω:', file.name);
            this.loadFile(file);
          }
        });

        document.addEventListener('dragover', e => e.preventDefault());
        document.addEventListener('drop', e => e.preventDefault());
      }

      async loadFile(file) {
        try {
          console.log('üìñ –ß—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–∞...');
          const text = await file.text();
          const json = JSON.parse(text);
          console.log('‚úÖ JSON —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–æ–±—Ä–∞–Ω, –∫–∞–¥—Ä–æ–≤:', json.frames?.length || 0);
          this.ingest(json);
        } catch (error) {
          console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞:', error);
          alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª: ' + error.message);
        }
      }

      createDemoData() {
        console.log('üéÆ –°–æ–∑–¥–∞–Ω–∏–µ –¥–µ–º–æ-–¥–∞–Ω–Ω—ã—Ö...');

        const demoData = {
          battle_id: "demo_battle_3d",
          start_time: Date.now() / 1000,
          end_time: Date.now() / 1000 + 12,
          red_team_size: 2,
          blue_team_size: 2,
          winner: "red",
          field_bounds: { x_min: -10, x_max: 10, y_min: -8, y_max: 8, z_min: 0, z_max: 6 },
          laser_config: { max_range: 8, damage: 15 },
          boundary_deaths: 0,
          frames: []
        };

        for (let i = 0; i < 60; i++) {
          const frame = {
            timestamp: demoData.start_time + i * 0.2,
            step: i,
            field_bounds: demoData.field_bounds,
            laser_config: demoData.laser_config,
            events: [],
            global_state: {},
            robots: [
              {
                id: "red_0",
                team: "red",
                x: -5 + Math.sin(i * 0.1) * 2,
                y: -2 + Math.cos(i * 0.15) * 1.5,
                z: 2 + Math.sin(i * 0.2) * 1,
                hp: Math.max(0, 100 - i * 1.2),
                alive: 100 - i * 1.2 > 0,
                within_bounds: true,
                target_enemy: 0,
                move_action: [0.1, 0.05, 0.02],
                aim_action: [0.2, -0.1, 0.0],
                fire_action: i % 10 === 0,
                laser_range: 8.0
              },
              {
                id: "red_1",
                team: "red",
                x: -3 + Math.cos(i * 0.12) * 1.5,
                y: 1 + Math.sin(i * 0.18) * 2,
                z: 1.5 + Math.cos(i * 0.25) * 0.8,
                hp: Math.max(0, 100 - i * 1.0),
                alive: 100 - i * 1.0 > 0,
                within_bounds: true,
                target_enemy: 1,
                move_action: [-0.05, 0.1, -0.01],
                aim_action: [-0.15, 0.2, 0.05],
                fire_action: i % 8 === 0,
                laser_range: 8.0
              },
              {
                id: "blue_0",
                team: "blue",
                x: 5 + Math.sin(i * 0.11) * -1.8,
                y: 2 + Math.cos(i * 0.16) * -1.2,
                z: 2.5 + Math.sin(i * 0.22) * 0.9,
                hp: Math.max(0, 100 - i * 1.5),
                alive: 100 - i * 1.5 > 0,
                within_bounds: true,
                target_enemy: 0,
                move_action: [-0.1, -0.08, 0.03],
                aim_action: [-0.25, 0.15, -0.02],
				fire_action: i % 12 === 0,
                laser_range: 8.0
              },
              {
                id: "blue_1",
                team: "blue",
                x: 3 + Math.cos(i * 0.13) * -2.2,
                y: -1 + Math.sin(i * 0.14) * -1.8,
                z: 1.8 + Math.cos(i * 0.28) * 1.1,
                hp: Math.max(0, 100 - i * 1.3),
                alive: 100 - i * 1.3 > 0,
                within_bounds: true,
                target_enemy: 1,
                move_action: [0.08, -0.12, -0.02],
                aim_action: [0.18, -0.22, 0.08],
                fire_action: i % 15 === 0,
                laser_range: 8.0
              }
            ]
          };

          if (i % 10 === 0) {
            frame.events.push({
              type: "fire",
              timestamp: frame.timestamp,
              robot_id: "red_0",
              target_id: "blue_0",
              position: [frame.robots[0].x, frame.robots[0].y, frame.robots[0].z],
              distance: 8.5,
              success: true
            });
          }

          demoData.frames.push(frame);
        }

        console.log('‚úÖ –î–µ–º–æ-–¥–∞–Ω–Ω—ã–µ —Å–æ–∑–¥–∞–Ω—ã —Å', demoData.frames.length, '–∫–∞–¥—Ä–∞–º–∏');
        this.ingest(demoData);
      }

      ingest(json) {
        console.log('üì• –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –±–æ—è...');

        this.data = json;
        this.frames = Array.isArray(json.frames) ? json.frames : [];
        this.bounds = json.field_bounds || (this.frames[0]?.field_bounds) || 
                     { x_min: -10, x_max: 10, y_min: -8, y_max: 8, z_min: 0, z_max: 6 };
        this.laser = json.laser_config || { max_range: 8, damage: 15, accuracy_falloff: 0.1 };

        console.log('üìä –î–∞–Ω–Ω—ã–µ –±–æ—è:', {
          id: json.battle_id,
          frames: this.frames.length,
          bounds: this.bounds,
          laser: this.laser
        });

        this.$('tot').textContent = this.frames.length;
        this.$('frame').max = this.frames.length ? (this.frames.length - 1) : 0;
        this.$('hint').classList.add('hidden');

        this.clearScene();

        if (this.scene) {
          this.buildField();
        }

        this.pause();
        this.cur = 0;
        this.updateFrame(true);

        console.log('‚úÖ –î–∞–Ω–Ω—ã–µ –±–æ—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã');
      }

      clearScene() {
        this.robots.clear();
        this.clearTrails();
      }
    }

    window.addEventListener('load', () => {
      console.log('üöÄ –ó–∞–ø—É—Å–∫ Arena 3D Visualizer...');
      
      window.visualizer = new Visualizer();
      window.visualizer.initialize().catch(error => {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ visualizer:', error);
      });
    });

    window.debugVis = {
      createTestRobot: () => {
        if (window.visualizer && window.visualizer.scene) {
          const testData = {
            id: "test_robot",
            team: "red",
            x: 0, y: 0, z: 2,
            hp: 75,
            alive: true,
            within_bounds: true,
            target_enemy: 0,
            move_action: [0.1, 0.0, 0.0],
            aim_action: [1.0, 0.0, 0.0],
            fire_action: false
          };

          const robot = window.visualizer.createRobotMesh(testData);
          window.visualizer.scene.add(robot);
          window.visualizer.robots.set("test_robot", robot);
          window.visualizer.updateRobotMesh(robot, testData);

          console.log('ü§ñ –¢–µ—Å—Ç–æ–≤—ã–π —Ä–æ–±–æ—Ç —Å–æ–∑–¥–∞–Ω');
        }
      },

      logScene: () => {
        if (window.visualizer && window.visualizer.scene) {
          console.log('–û–±—ä–µ–∫—Ç—ã —Å—Ü–µ–Ω—ã:', window.visualizer.scene.children.length);
          console.log('–†–æ–±–æ—Ç—ã:', window.visualizer.robots.size);
          console.log('–¢–µ–∫—É—â–∏–π –∫–∞–¥—Ä:', window.visualizer.cur);
          console.log('–í—Å–µ–≥–æ –∫–∞–¥—Ä–æ–≤:', window.visualizer.frames.length);
        }
      },

      testCamera: () => {
        if (window.visualizer && window.visualizer.controls) {
          console.log('–ö–∞–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏—è:', window.visualizer.camera.position);
          console.log('–ö–∞–º–µ—Ä–∞ —Ü–µ–ª—å:', window.visualizer.controls.target);
          console.log('–ö–æ–Ω—Ç—Ä–æ–ª—ã –≤–∫–ª—é—á–µ–Ω—ã:', window.visualizer.controls.enabled);
        }
      },

      resetCamera: () => {
        if (window.visualizer) {
          window.visualizer.setCam('overview');
          console.log('üì∑ –ö–∞–º–µ—Ä–∞ —Å–±—Ä–æ—à–µ–Ω–∞ –Ω–∞ –æ–±–∑–æ—Ä–Ω—ã–π —Ä–∞–∫—É—Ä—Å');
        }
      }
    };
  </script>
</body>
</html>
        
        if (this.scene) {
          const toRemove = [];
          this.scene.traverse(child => {
            if (child.name && (child.name.startsWith('red_') || child.name.startsWith('blue_'))) {
              toRemove.push(child);
            }
          });
          toRemove.forEach(child => this.scene.remove(child));
        }
      }

      clearTrails() {
        this.trails.clear();
        this.trailsLines.forEach(line => {
          if (this.scene) this.scene.remove(line);
          if (line.geometry) line.geometry.dispose();
        });
        this.trailsLines.clear();
      }

      async init3D() {
        if (typeof THREE === 'undefined') {
          throw new Error('THREE.js –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω');
        }

        console.log('üé¨ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è 3D —Å—Ü–µ–Ω—ã...');

        const container = this.$('threejs-container');

        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x0b1020, 30, 80);

        const width = container.clientWidth || 800;
        const height = container.clientHeight || 600;
        this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 500);
        this.camera.position.set(18, 14, 18);

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setPixelRatio(window.devicePixelRatio || 1);
        this.renderer.setSize(width, height);
        this.renderer.setClearColor(0x071019, 1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        container.innerHTML = '';
        container.appendChild(this.renderer.domElement);

        if (THREE.OrbitControls) {
          try {
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.screenSpacePanning = false;
            
            this.controls.minDistance = 2;
            this.controls.maxDistance = 100;
            this.controls.maxPolarAngle = Math.PI * 0.9;
            
            this.controls.rotateSpeed = 1.0;
            this.controls.panSpeed = 0.8;
            this.controls.zoomSpeed = 1.0;
            
            this.controls.enableRotate = true;
            this.controls.enableZoom = true;
            this.controls.enablePan = true;
            
            console.log('‚úÖ OrbitControls –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏');
            this.$('cameraHelp').style.display = 'block';
            
          } catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ OrbitControls:', error);
          }
        } else {
          console.warn('‚ö†Ô∏è OrbitControls –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã');
        }

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(16, 24, 12);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        this.scene.add(directionalLight);

        this.fieldGroup = new THREE.Group();
        this.scene.add(this.fieldGroup);
        this.buildField();

        this.renderer.domElement.addEventListener('click', e => this.onClick(e));

        const onResize = () => {
          const w = container.clientWidth;
          const h = container.clientHeight;
          this.camera.aspect = w / h;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(w, h);
        };
        window.addEventListener('resize', onResize);

        const animate = () => {
          requestAnimationFrame(animate);

          if (this.controls && this.controls.update) {
            this.controls.update();
          }

          if (this.showTrails && this.trails.size > 0) {
            this.updateTrails();
          }

          if (this.followId && this.robots.has(this.followId) && this.controls) {
            const robotGroup = this.robots.get(this.followId);
            const offset = new THREE.Vector3(4, 3, 6);
            const targetPos = robotGroup.position.clone().add(offset);
            
            this.camera.position.lerp(targetPos, 0.02);
            this.controls.target.lerp(robotGroup.position, 0.05);
          }

          this.renderer.render(this.scene, this.camera);
        };
        animate();

        this.updateDebugStatus();
        console.log('‚úÖ 3D —Å—Ü–µ–Ω–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
      }

      buildField() {
        if (!this.bounds || !this.scene) return;

        console.log('üèüÔ∏è –°–æ–∑–¥–∞–Ω–∏–µ 3D –ø–æ–ª—è —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏:', this.bounds);

        this.fieldGroup.clear();

        const b = this.bounds;
        const W = b.x_max - b.x_min;
        const H = b.y_max - b.y_min;
        const D = b.z_max - b.z_min;
        const centerX = (b.x_min + b.x_max) / 2;
        const centerY = (b.y_min + b.y_max) / 2;
        const centerZ = (b.z_min + b.z_max) / 2;

        const planeGeometry = new THREE.PlaneGeometry(W, H);
        const planeMaterial = new THREE.MeshLambertMaterial({
          color: 0x0b2a3a,
          transparent: true,
          opacity: 0.3
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(centerX, b.z_min, centerY);
        plane.receiveShadow = true;
        this.fieldGroup.add(plane);

        const gridHelper = new THREE.GridHelper(Math.max(W, H), 20, 0x274c77, 0x1a3a5c);
        gridHelper.position.set(centerX, b.z_min + 0.01, centerY);
        this.fieldGroup.add(gridHelper);

        const boxGeometry = new THREE.BoxGeometry(W, D, H);
        const boxMaterial = new THREE.MeshBasicMaterial({
          color: 0x3b82f6,
          wireframe: true,
          transparent: true,
          opacity: 0.6
        });
        const boxHelper = new THREE.Mesh(boxGeometry, boxMaterial);
        boxHelper.position.set(centerX, centerZ, centerY);
        this.fieldGroup.add(boxHelper);

        const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
        const cornerGeometry = new THREE.SphereGeometry(0.2, 8, 8);

        const corners = [
          [b.x_min, b.z_min, b.y_min], [b.x_max, b.z_min, b.y_min],
          [b.x_min, b.z_min, b.y_max], [b.x_max, b.z_min, b.y_max],
          [b.x_min, b.z_max, b.y_min], [b.x_max, b.z_max, b.y_min],
          [b.x_min, b.z_max, b.y_max], [b.x_max, b.z_max, b.y_max]
        ];

        corners.forEach(([x, y, z]) => {
          const corner = new THREE.Mesh(cornerGeometry, cornerMaterial);
          corner.position.set(x, y, z);
          this.fieldGroup.add(corner);
        });

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4ade80 });
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(centerX, b.z_min, b.y_min),
          new THREE.Vector3(centerX, b.z_min, b.y_max)
        ]);
        const centerLine = new THREE.Line(lineGeometry, lineMaterial);
        this.fieldGroup.add(centerLine);

        this.fieldGroup.visible = this.showBounds;
        console.log('‚úÖ 3D –ø–æ–ª–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–æ');
      }

      createRobotMesh(data) {
        console.log('ü§ñ –°–æ–∑–¥–∞–Ω–∏–µ –º–µ—à–∞ —Ä–æ–±–æ—Ç–∞ –¥–ª—è:', data.id);

        const group = new THREE.Group();
        group.name = data.id;

        const bodyGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.8);
        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: data.team === 'red' ? 0xff5757 : 0x5b8dff,
          metalness: 0.2,
          roughness: 0.4
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.3;
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);

        const headGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.3, 8);
        const headMaterial = new THREE.MeshStandardMaterial({
          color: data.team === 'red' ? 0xcc4444 : 0x4477cc,
          metalness: 0.3,
          roughness: 0.3
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 0.75;
        head.castShadow = true;
        group.add(head);

        const gunGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.8, 8);
        const gunMaterial = new THREE.MeshStandardMaterial({
          color: 0xffe066,
          emissive: 0x332200,
          emissiveIntensity: 0.3,
          metalness: 0.7,
          roughness: 0.2
        });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.rotation.z = Math.PI / 2;
        gun.position.set(0.6, 0.4, 0);
        gun.name = 'gun';
        gun.castShadow = true;
        group.add(gun);

        const hpBgGeometry = new THREE.PlaneGeometry(1.0, 0.1);
        const hpBgMaterial = new THREE.MeshBasicMaterial({
          color: 0x334155,
          transparent: true,
          opacity: 0.8
        });
        const hpBg = new THREE.Mesh(hpBgGeometry, hpBgMaterial);
        hpBg.position.set(0, 1.2, 0);
        hpBg.name = 'hpBg';
        group.add(hpBg);

        const hpGeometry = new THREE.PlaneGeometry(1.0, 0.1);
        const hpMaterial = new THREE.MeshBasicMaterial({
          color: 0x22c55e,
          transparent: true,
          opacity: 0.9
        });
        const hp = new THREE.Mesh(hpGeometry, hpMaterial);
        hp.position.set(0, 1.2, 0.01);
        hp.name = 'hp';
        group.add(hp);

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        context.fillStyle = 'rgba(0, 0, 0, 0.7)';
        context.fillRect(0, 0, 256, 64);
        context.fillStyle = data.team === 'red' ? '#ff5757' : '#5b8dff';
        context.font = '24px Arial';
        context.textAlign = 'center';
        context.fillText(data.id, 128, 40);

        const labelTexture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.MeshBasicMaterial({
          map: labelTexture,
          transparent: true,
          alphaTest: 0.1
        });
        const labelGeometry = new THREE.PlaneGeometry(1.5, 0.4);
        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        label.position.set(0, 1.6, 0);
        label.name = 'label';
        group.add(label);

        group.userData = {
          selected: false,
          team: data.team
        };

        return group;
      }

      updateRobotMesh(group, data) {
        if (!group || !data) return;

        group.position.set(data.x || 0, data.z || 2, data.y || 0);

        const hp = group.getObjectByName('hp');
        if (hp) {
          const hpPercent = Math.max(0, Math.min(1, (data.hp || 0) / 100));
          hp.scale.x = hpPercent;
          hp.position.x = (hpPercent - 1) * 0.5;

          if (hpPercent > 0.6) hp.material.color.setHex(0x22c55e);
          else if (hpPercent > 0.3) hp.material.color.setHex(0xf59e0b);
          else hp.material.color.setHex(0xef4444);
        }

        const scaleAlive = data.alive ? 1 : 0.7;
        group.scale.set(scaleAlive, scaleAlive, scaleAlive);

        if (this.showTrails && data.alive) {
          if (!this.trails.has(data.id)) {
            this.trails.set(data.id, []);
          }
          const trail = this.trails.get(data.id);
          const currentPos = new THREE.Vector3(
            group.position.x,
            group.position.y + 0.1,
            group.position.z
          );

          if (trail.length === 0 || currentPos.distanceTo(trail[trail.length - 1]) > 0.1) {
            trail.push(currentPos);
            if (trail.length > 100) trail.shift();
          }
        }

        if (data.fire_action && data.alive) {
          this.createLaserEffect(group.position, data.aim_action || [1, 0, 0]);
        }
      }

      createLaserEffect(position, aimDirection) {
        const laserGeometry = new THREE.CylinderGeometry(0.02, 0.02, 8, 8);
        const laserMaterial = new THREE.MeshBasicMaterial({
          color: 0xff6600,
          transparent: true,
          opacity: 0.8,
          emissive: 0xff3300,
          emissiveIntensity: 0.5
        });

        const laser = new THREE.Mesh(laserGeometry, laserMaterial);
        laser.position.copy(position);
        laser.position.y += 0.4;

        const [aimX, aimY, aimZ] = aimDirection;
        const direction = new THREE.Vector3(aimX || 1, aimY || 0, aimZ || 0).normalize();
        laser.lookAt(laser.position.clone().add(direction));
        laser.rotateX(Math.PI / 2);

        this.scene.add(laser);

        let opacity = 0.8;
        const fadeOut = () => {
          opacity -= 0.05;
          laser.material.opacity = opacity;
          if (opacity <= 0) {
            this.scene.remove(laser);
            laser.geometry.dispose();
            laser.material.dispose();
          } else {
            requestAnimationFrame(fadeOut);
          }
        };

        setTimeout(fadeOut, 100);
      }

      updateTrails() {
        if (!this.showTrails) return;

        for (const [robotId, points] of this.trails.entries()) {
          if (points.length < 2) continue;

          let trailLine = this.trailsLines.get(robotId);
          const geometry = new THREE.BufferGeometry().setFromPoints(points);

          if (!trailLine) {
            const robot = this.robots.get(robotId);
            const isRed = robot?.userData?.team === 'red';
            const color = isRed ? 0xff9999 : 0x9999ff;

            const material = new THREE.LineBasicMaterial({
              color: color,
              transparent: true,
              opacity: 0.6
            });

            trailLine = new THREE.Line(geometry, material);
            this.trailsLines.set(robotId, trailLine);
            this.scene.add(trailLine);
          } else {
            trailLine.geometry.dispose();
            trailLine.geometry = geometry;
          }
        }
      }

      updateFrame(syncSlider = false) {
        if (!this.frames.length || !this.scene) return;

        const frame = this.frames[this.cur];
        if (!frame) return;

        (frame.robots || []).forEach(robotData => {
          let robotGroup = this.robots.get(robotData.id);

          if (!robotGroup) {
            robotGroup = this.createRobotMesh(robotData);
            this.scene.add(robotGroup);
            this.robots.set(robotData.id, robotGroup);
          }

          this.updateRobotMesh(robotGroup, robotData);
        });

        const currentRobotIds = new Set((frame.robots || []).map(r => r.id));
        for (const [robotId, robotGroup] of this.robots.entries()) {
          if (!currentRobotIds.has(robotId)) {
            this.scene.remove(robotGroup);
            this.robots.delete(robotId);
          }
        }

        this.updateBattleStats(frame.robots || []);

        const startTime = this.data?.start_time || 0;
        const currentTime = (frame.timestamp || 0) - startTime;
        this.$('battleTime').textContent = (currentTime > 0 ? currentTime.toFixed(1) : '0') + '—Å';

        if (syncSlider) {
          this.$('cur').textContent = this.cur;
          this.$('frame').value = this.cur;
        }

        this.renderEvents(frame.events || []);
        this.updateDebugStatus();
      }

      updateBattleStats(robots) {
        let redHP = 0, blueHP = 0, alive = 0;

        robots.forEach(robot => {
          if (robot.alive) {
            alive++;
            if (robot.team === 'red') {
              redHP += robot.hp || 0;
            } else if (robot.team === 'blue') {
              blueHP += robot.hp || 0;
            }
          }
        });

        this.$('redHP').textContent = Math.round(redHP);
        this.$('blueHP').textContent = Math.round(blueHP);
        this.$('aliveCount').textContent = alive;
      }

      renderEvents(events) {
        if (!events || !events.length) {
          this.$('events').textContent = '–°–æ–±—ã—Ç–∏–π –ø–æ–∫–∞ –Ω–µ—Ç';
          return;
        }

        const recentEvents = events.slice(-8).reverse();
        const eventNames = {
          'fire': 'üî• –í—ã—Å—Ç—Ä–µ–ª',
          'hit': 'üéØ –ü–æ–ø–∞–¥–∞–Ω–∏–µ', 
          'death': 'üíÄ –°–º–µ—Ä—Ç—å',
          'boundary_violation': '‚ö†Ô∏è –ó–∞ –≥—Ä–∞–Ω–∏—Ü–µ–π',
          'laser_miss': '‚ùå –ü—Ä–æ–º–∞—Ö'
        };

        const eventsHtml = recentEvents.map(event => {
          const type = eventNames[event.type] || event.type;
          const robotId = event.robot_id || event.robot || '';
          const targetId = event.target_id ? ` ‚Üí ${event.target_id}` : '';
          const distance = (event.distance != null) ? ` ‚Ä¢ ${Number(event.distance).toFixed(1)}–º` : '';
          const success = event.success ? ' ‚úÖ' : (event.success === false ? ' ‚ùå' : '');

          return `<div class="kv">
            <span>${type}${success}</span>
            <span class="mono">${robotId}${targetId}${distance}</span>
          </div>`;
        }).join('');

        this.$('events').innerHTML = eventsHtml;
      }

      onClick(event) {
        if (!this.renderer || !this.camera || !this.scene) return;

        const rect = this.renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
          ((event.clientX - rect.left) / rect.width) * 2 - 1,
          -((event.clientY - rect.top) / rect.height) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);

        const robotGroups = Array.from(this.robots.values());
        const intersects = raycaster.intersectObjects(robotGroups, true);

        if (intersects.length > 0) {
          let targetGroup = intersects[0].object;

          while (targetGroup.parent && !this.robots.has(targetGroup.name)) {
            targetGroup = targetGroup.parent;
          }

          if (this.robots.has(targetGroup.name)) {
            this.selectRobot(targetGroup.name);
          }
        }
      }

      selectRobot(robotId) {
        console.log('üéØ –í—ã–±—Ä–∞–Ω —Ä–æ–±–æ—Ç:', robotId);

        this.robots.forEach(group => {
          group.userData.selected = false;
        });

        const robotGroup = this.robots.get(robotId);
        if (robotGroup) {
          robotGroup.userData.selected = true;
          this.followId = robotId;

          const frame = this.frames[this.cur];
          const robotData = frame?.robots?.find(r => r.id === robotId);

          if (robotData) {
            const teamColor = robotData.team === 'red' ? '#ff5757' : '#5b8dff';
            const info = `
              <div class="kv"><span>ID</span><span class="mono">${robotData.id}</span></div>
              <div class="kv"><span>–ö–æ–º–∞–Ω–¥–∞</span><span style="color: ${teamColor}">${robotData.team === 'red' ? '–ö—Ä–∞—Å–Ω–∞—è' : '–°–∏–Ω—è—è'}</span></div>
              <div class="kv"><span>HP</span><span>${Math.round(robotData.hp || 0)}/100</span></div>
              <div class="kv"><span>–ü–æ–∑–∏—Ü–∏—è</span><span class="mono">[${robotData.x?.toFixed(1)}, ${robotData.y?.toFixed(1)}, ${robotData.z?.toFixed(1)}]</span></div>
              <div class="kv"><span>–ñ–∏–≤</span><span>${robotData.alive ? '‚úÖ' : '‚ùå'}</span></div>
              <div class="kv"><span>–í –≥—Ä–∞–Ω–∏—Ü–∞—Ö</span><span>${robotData.within_bounds ? '‚úÖ' : '‚ùå'}</span></div>
              <div class="kv"><span>–¶–µ–ª—å</span><span>${robotData.target_enemy}</span></div>
              <div class="kv"><span>–°—Ç—Ä–µ–ª—è–µ—Ç</span><span>${robotData.fire_action ? 'üî•' : '‚≠ï'}</span></div>
              <div class="kv"><span>–°–ª–µ–¥–æ–≤–∞–Ω–∏–µ</span><span>–í–ö–õ</span></div>
            `;
            this.$('robotInfo').innerHTML = info;
          }
        }
      }

      setCam(preset) {
        if (!this.bounds || !this.camera) return;

        const centerX = (this.bounds.x_min + this.bounds.x_max) / 2;
        const centerY = (this.bounds.y_min + this.bounds.y_max) / 2;
        const centerZ = (this.bounds.z_min + this.bounds.z_max) / 2;
        const target = new THREE.Vector3(centerX, centerZ, centerY);

        console.log('üì∑ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–∞–∫—É—Ä—Å–∞ –∫–∞–º–µ—Ä—ã:', preset);

        switch (preset) {
          case 'overview':
            this.camera.position.set(centerX + 20, centerZ + 16, centerY + 20);
            if (this.controls) this.controls.target.copy(target);
            this.followId = null;
            break;

          case 'side':
            this.camera.position.set(centerX + 25, centerZ + 8, centerY);
            if (this.controls) this.controls.target.copy(target);
            this.followId = null;
            break;

          case 'top':
            this.camera.position.set(centerX, centerZ + 30, centerY);
            if (this.controls) this.controls.target.copy(target);
            this.followId = null;
            break;

          case 'follow':
            if (this.followId && this.robots.has(this.followId)) {
              const robotGroup = this.robots.get(this.followId);
              const offset = new THREE.Vector3(5, 4, 8);
              this.camera.position.copy(robotGroup.position).add(offset);
              if (this.controls) this.controls.target.copy(robotGroup.position);
            } else if (this.robots.size > 0) {
              const firstRobot = this.robots.values().next().value;
              this.followId = firstRobot.name;
              this.selectRobot(this.followId);
            }
            break;
        }

        if (this.controls && this.controls.update) {
          this.controls.update();
        }
      }

      play() {
        if (!this.frames.length || this.isPlay) return;

        console.log('‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è');
        this.isPlay = true;

        const step = () => {
          if (!this.isPlay) return;

          if (this.cur < this.frames.length - 1) {
            this.cur++;
            this.updateFrame(true);

            const delay = Math.max(50, 150 / this.speed);
            setTimeout(step, delay);
          } else {
            console.log('‚èπÔ∏è –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ');
            this.isPlay = false;
          }
        };

        step();
      }

      pause() {
        console.log('‚è∏Ô∏è –ü–∞—É–∑–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è');
        this.isPlay = false;
      }

      reset() {
        console.log('‚ü≤ –°–±—Ä–æ—Å –∫ –ø–µ—Ä–≤–æ–º—É –∫–∞–¥—Ä—É');
        this.pause();
        this.cur = 0;
        this.updateFrame(true);
        this.clearTrails();<!DOCTYPE html>