<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Arena 3D Battle Visualizer</title>
  <style>
    :root{ --bg:#0b0f1a;--bg2:#0e1424;--panel:#121b30;--panel2:#0f1a33; --text:#e5ecff;--muted:#94a3b8;--border:#1f2a44;--chip:#1b2540; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;padding:0;background:linear-gradient(135deg,var(--bg),var(--bg2));color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; overflow:hidden; }
    .wrap{display:flex;flex-direction:column;height:100%}
    header{ padding:14px 18px;border-bottom:1px solid var(--border);
      display:flex;gap:16px;align-items:center;justify-content:space-between;background:linear-gradient(180deg,#121b30,#0f1a33); position:relative;z-index:2; }
    header .ttl{display:flex;align-items:center;gap:10px}
    header h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.3px}
    header .sub{font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{background:#1a2644;border:1px solid var(--border);color:var(--text); padding:8px 12px;border-radius:10px;cursor:pointer;transition:all .15s ease;font-weight:600}
    .btn:hover{transform:translateY(-1px);box-shadow:0 4px 14px rgba(0,0,0,.25)}
    .btn.ok{background:#11351f;border-color:#1b8a52}
    .btn.danger{background:#381417;border-color:#7a1d27}
    .btn.warn{background:#3a2a14;border-color:#7c4a00}
    .chip{background:var(--chip);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px}
    .tog{display:flex;align-items:center;gap:8px}
    .tog input{transform:scale(1.2)}
    .speed{display:flex;align-items:center;gap:8px}
    .layout{display:flex;flex:1 1 auto;min-height:0}
    .viewer{position:relative;flex:1 1 auto;min-width:0}
    #threejs-container{position:absolute;inset:0;z-index:1}
    .overlay-hint{ position:absolute;left:50%;top:16px;transform:translateX(-50%);
      background:#0f172a88;padding:8px 12px;border:1px solid var(--border);border-radius:10px;font-size:12px; pointer-events:none; }
    aside{ width:320px;max-width:35vw;border-left:1px solid var(--border);background:linear-gradient(180deg,#121b30,#0f1a33);
      display:flex;flex-direction:column;gap:12px;padding:12px;overflow:auto }
    .card{background:#0d142a;border:1px solid var(--border);border-radius:14px;padding:12px}
    .card h3{margin:0 0 6px;font-size:14px;letter-spacing:.3px}
    .row{display:flex;gap:10px}
    .stat{flex:1 1 0;background:#0c1326;border:1px solid var(--border);border-radius:12px;padding:10px;text-align:center}
    .stat .v{font-weight:800;font-size:20px}
    .stat.red{border-color:#7f1d1d}
    .stat.blue{border-color:#1d4ed8}
    .kv{display:flex;justify-content:space-between;padding:4px 0;color:var(--muted);font-size:12px}
    .timeline input[type=range]{width:100%}
    .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .robot-info{min-height:110px;max-height:180px;overflow:auto;font-size:12px}
    .drop{border:2px dashed #334155;border-radius:14px;background:#0b1226;padding:14px;text-align:center;cursor:pointer}
    .drop.drag{background:#0d1530;border-color:#64748b}
    .muted{color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .hidden{display:none !important}
    canvas{display:block;outline:none}
    @media (max-width: 1000px){aside{width:280px}}
    @media (max-width: 860px){
      .layout{flex-direction:column}
      aside{width:100%;max-width:none;height:40vh}
      .viewer{height:60vh}
    }
  </style>
</head>
<body>
  <script>
    document.addEventListener('dragover', e => e.preventDefault(), false);
    document.addEventListener('drop', e => e.preventDefault(), false);
  </script>

  <div class="wrap">
    <header>
      <div class="ttl">
        <div style="font-size:20px">üõ∞Ô∏è</div>
        <div>
          <h1>Arena 3D Battle Visualizer</h1>
          <div class="sub">3D-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—ë–≤ —Å –ª–∞–∑–µ—Ä–Ω—ã–º–∏ —Å–Ω–∞—Ä—è–¥–∞–º–∏ –∏ –±–∞–ª–ª–∏—Å—Ç–∏–∫–æ–π</div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å JSON –±–æ—è</button>
        <input type="file" id="fileInput" accept=".json" class="hidden"/>
        <button class="btn ok" id="btnPlay">‚ñ∂ –ü—É—Å–∫</button>
        <button class="btn" id="btnPause">‚è∏ –ü–∞—É–∑–∞</button>
        <button class="btn danger" id="btnReset">‚ü≤ –°–±—Ä–æ—Å</button>
        <span class="speed">
          <span>–°–∫–æ—Ä–æ—Å—Ç—å:</span>
          <input type="range" id="speed" min="0.2" max="3" step="0.1" value="1"/>
          <span id="speedVal" class="chip mono">1.0x</span>
        </span>
        <label class="tog"><input type="checkbox" id="toggleTrails" checked/><span>–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–ª–µ–¥—ã</span></label>
        <label class="tog"><input type="checkbox" id="toggleBounds" checked/><span>–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã</span></label>
        <label class="tog"><input type="checkbox" id="toggleProjectiles" checked/><span>–õ–∞–∑–µ—Ä–Ω—ã–µ —Å–Ω–∞—Ä—è–¥—ã</span></label>
        <button class="btn" id="btnCreateDemo">üéÆ –î–µ–º–æ-–¥–∞–Ω–Ω—ã–µ</button>
      </div>
    </header>

    <div class="layout">
      <section class="viewer">
        <div id="threejs-container"></div>
        <div class="overlay-hint muted mono" id="hint">–ó–∞–≥—Ä—É–∑–∏—Ç–µ battle_3d_*.json –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ</div>
      </section>

      <aside>
        <div class="card drop" id="dropZone">üìÅ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ JSON –±–æ—è —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</div>
        <div class="card">
          <h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—è</h3>
          <div class="row">
            <div class="stat red"><div>HP –∫–æ–º–∞–Ω–¥—ã Red</div><div class="v" id="redHP">0</div></div>
            <div class="stat blue"><div>HP –∫–æ–º–∞–Ω–¥—ã Blue</div><div class="v" id="blueHP">0</div></div>
          </div>
          <div class="row" style="margin-top:8px">
            <div class="stat"><div>–ñ–∏–≤—ã</div><div class="v" id="aliveCount">0</div></div>
            <div class="stat"><div>–í—Ä–µ–º—è</div><div class="v" id="battleTime">0s</div></div>
          </div>
          <div class="row" style="margin-top:8px">
            <div class="stat"><div>–í—ã—Å—Ç—Ä–µ–ª–æ–≤</div><div class="v" id="shotsFired">0</div></div>
            <div class="stat"><div>–ü–æ–ø–∞–¥–∞–Ω–∏–π</div><div class="v" id="shotsHit">0</div></div>
          </div>
        </div>
        <div class="card timeline">
          <h3>‚è∞ –®–∫–∞–ª–∞ –≤—Ä–µ–º–µ–Ω–∏</h3>
          <input type="range" id="frame" min="0" max="0" value="0"/>
          <div class="kv"><span>–ö–∞–¥—Ä: <span id="cur">0</span></span><span>–í—Å–µ–≥–æ: <span id="tot">0</span></span></div>
        </div>
        <div class="card">
          <h3>üì∑ –ö–∞–º–µ—Ä–∞</h3>
          <div class="grid">
            <button class="btn" data-cam="overview">üèüÔ∏è –û–±–∑–æ—Ä</button>
            <button class="btn" data-cam="side">üìê –°–±–æ–∫—É</button>
            <button class="btn" data-cam="top">‚¨áÔ∏è –°–≤–µ—Ä—Ö—É</button>
            <button class="btn" data-cam="follow">üéØ –°–ª–µ–¥–æ–≤–∞—Ç—å</button>
          </div>
          <div class="muted" style="margin-top:8px">üñ±Ô∏è –í—Ä–∞—â–µ–Ω–∏–µ/–ó—É–º ‚Ä¢ ‚§¢ –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞: –ü–∞–Ω–æ—Ä–∞–º–∞</div>
        </div>
        <div class="card">
          <h3>ü§ñ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–æ–±–æ—Ç–µ</h3>
          <div id="robotInfo" class="robot-info">–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —Ä–æ–±–æ—Ç—É, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–µ—Ç–∞–ª–∏</div>
        </div>
        <div class="card">
          <h3>üéûÔ∏è –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è</h3>
          <div id="events" class="robot-info">–°–æ–±—ã—Ç–∏–π –ø–æ–∫–∞ –Ω–µ—Ç</div>
        </div>
      </aside>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "./three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './OrbitControls.js';

    class LaserProjectile {
      constructor(startPos, targetPos, robotData, scene, visualizer) {
        this.scene = scene;
        this.visualizer = visualizer;
        this.robotData = robotData;
        this.startPos = startPos.clone();
        this.targetPos = targetPos.clone();
        this.currentPos = startPos.clone();
        this.speed = 25.0; // units per second
        this.maxRange = robotData.laser_range || 8.0;
        this.accuracy = this.calculateAccuracy();
        this.isActive = true;
        this.startTime = Date.now();
        this.hasHit = false;

        // Calculate actual target with accuracy spread
        this.actualTarget = this.calculateActualTarget();
        this.direction = this.actualTarget.clone().sub(this.startPos).normalize();
        this.totalDistance = this.startPos.distanceTo(this.actualTarget);
        
        this.createMesh();
        this.scene.add(this.mesh);
      }

      calculateAccuracy() {
        if (!this.robotData.aim_action) return 0.8;
        
        const aimVector = new THREE.Vector3(
          this.robotData.aim_action[0] || 0,
          this.robotData.aim_action[1] || 0,
          this.robotData.aim_action[2] || 0
        );
        
        // Better aim (smaller aim vector) = higher accuracy
        const aimMagnitude = aimVector.length();
        const baseAccuracy = 0.9;
        const aimPenalty = Math.min(0.5, aimMagnitude * 0.3);
        
        // Distance penalty
        const distance = this.startPos.distanceTo(this.targetPos);
        const distancePenalty = Math.min(0.4, (distance / this.maxRange) * 0.3);
        
        return Math.max(0.2, baseAccuracy - aimPenalty - distancePenalty);
      }

      calculateActualTarget() {
        const accuracy = this.accuracy;
        const spread = (1 - accuracy) * 2.0; // Max spread of 2 units for worst accuracy
        
        const target = this.targetPos.clone();
        
        // Add random spread around the target
        const spreadX = (Math.random() - 0.5) * spread;
        const spreadY = (Math.random() - 0.5) * spread;
        const spreadZ = (Math.random() - 0.5) * spread * 0.5; // Less vertical spread
        
        target.add(new THREE.Vector3(spreadX, spreadZ, spreadY));
        
        // Ensure target is within max range
        const distance = this.startPos.distanceTo(target);
        if (distance > this.maxRange) {
          const direction = target.clone().sub(this.startPos).normalize();
          target.copy(this.startPos).add(direction.multiplyScalar(this.maxRange));
        }
        
        return target;
      }

      createMesh() {
        // Create projectile visual
        const geometry = new THREE.SphereGeometry(0.08, 8, 8);
        const material = new THREE.MeshBasicMaterial({ 
          color: 0xff4400,
          emissive: 0xff2200,
          emissiveIntensity: 0.8
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(this.currentPos);

        // Create trail effect
        this.trailPoints = [this.currentPos.clone()];
        this.createTrail();
      }

      createTrail() {
        const trailGeometry = new THREE.BufferGeometry();
        const trailMaterial = new THREE.LineBasicMaterial({ 
          color: 0xff6600,
          transparent: true,
          opacity: 0.6
        });
        
        this.trailLine = new THREE.Line(trailGeometry, trailMaterial);
        this.scene.add(this.trailLine);
      }

      updateTrail() {
        if (this.trailPoints.length > 10) {
          this.trailPoints.shift();
        }
        this.trailPoints.push(this.currentPos.clone());
        
        this.trailLine.geometry.dispose();
        this.trailLine.geometry = new THREE.BufferGeometry().setFromPoints(this.trailPoints);
      }

      update(deltaTime) {
        if (!this.isActive) return false;

        const distance = this.speed * deltaTime;
        const movement = this.direction.clone().multiplyScalar(distance);
        this.currentPos.add(movement);
        
        this.mesh.position.copy(this.currentPos);
        this.updateTrail();

        // Check if reached target or max range
        const traveledDistance = this.startPos.distanceTo(this.currentPos);
        const targetDistance = this.currentPos.distanceTo(this.actualTarget);
        
        if (targetDistance < 0.2 || traveledDistance >= this.totalDistance) {
          this.checkForHit();
          this.explode();
          return false;
        }

        // Check for collision with robots
        this.checkRobotCollision();
        
        return true;
      }

      checkRobotCollision() {
        if (this.hasHit) return;

        const robots = this.visualizer.robots;
        for (const [robotId, robotMesh] of robots.entries()) {
          if (robotId === this.robotData.id) continue; // Don't hit self
          
          const distance = this.currentPos.distanceTo(robotMesh.position);
          if (distance < 0.8) { // Robot collision radius
            const frame = this.visualizer.frames[this.visualizer.cur];
            const targetRobot = frame?.robots?.find(r => r.id === robotId);
            
            if (targetRobot && targetRobot.alive) {
              this.hasHit = true;
              this.explode(true);
              this.visualizer.registerHit(this.robotData.id, robotId, this.currentPos);
              return;
            }
          }
        }
      }

      checkForHit() {
        if (this.hasHit) return;

        // Check if close enough to intended target
        const frame = this.visualizer.frames[this.visualizer.cur];
        if (!frame) return;

        const targetRobot = frame.robots?.find(r => 
          r.team !== this.robotData.team && r.alive
        );

        if (targetRobot) {
          const targetPos = new THREE.Vector3(targetRobot.x, targetRobot.z, targetRobot.y);
          const hitDistance = this.currentPos.distanceTo(targetPos);
          
          if (hitDistance < 1.0) { // Hit tolerance
            this.hasHit = true;
            this.visualizer.registerHit(this.robotData.id, targetRobot.id, this.currentPos);
          }
        }
      }

      explode(hit = false) {
        this.isActive = false;
        
        // Create explosion effect
        const explosionGeometry = new THREE.SphereGeometry(hit ? 0.5 : 0.3, 12, 12);
        const explosionMaterial = new THREE.MeshBasicMaterial({
          color: hit ? 0xff0000 : 0xffaa00,
          transparent: true,
          opacity: 0.8
        });
        
        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
        explosion.position.copy(this.currentPos);
        this.scene.add(explosion);

        // Animate explosion
        let scale = 0.1;
        let opacity = 0.8;
        const animate = () => {
          scale += 0.1;
          opacity -= 0.05;
          
          explosion.scale.setScalar(scale);
          explosion.material.opacity = opacity;
          
          if (opacity <= 0) {
            this.scene.remove(explosion);
            explosion.geometry.dispose();
            explosion.material.dispose();
          } else {
            requestAnimationFrame(animate);
          }
        };
        animate();
      }

      destroy() {
        if (this.mesh) {
          this.scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
        }
        
        if (this.trailLine) {
          this.scene.remove(this.trailLine);
          this.trailLine.geometry.dispose();
          this.trailLine.material.dispose();
        }
      }
    }

    class Visualizer {
      constructor(){
        this.data=null; this.frames=[]; this.bounds=null; this.laser=null;
        this.cur=0; this.isPlay=false; this.speed=1; this.showBounds=true; this.showTrails=true; this.showProjectiles=true;
        this.recent=[]; this.robots=new Map(); this.trails=new Map(); this.trailsLines=new Map(); this.followId=null;
        this.projectiles = new Set(); this.battleStats = { shotsFired: 0, shotsHit: 0 };

        this.$=id=>document.getElementById(id);
        this.hookUI();
        this.hookFile();
        this.init3D();
      }

      registerHit(shooterId, targetId, position) {
        this.battleStats.shotsHit++;
        this.updateBattleStatsUI();
        
        // Add hit event to recent events
        this.recent.unshift({
          type: 'hit',
          shooter: shooterId,
          target: targetId,
          timestamp: Date.now(),
          position: position.toArray()
        });
        
        if (this.recent.length > 20) {
          this.recent.pop();
        }
      }

      updateBattleStatsUI() {
        this.$('shotsFired').textContent = this.battleStats.shotsFired;
        this.$('shotsHit').textContent = this.battleStats.shotsHit;
      }

      hookUI(){
        this.$('btnLoad').onclick=()=>this.$('fileInput').click();
        this.$('btnPlay').onclick=()=>this.play();
        this.$('btnPause').onclick=()=>this.pause();
        this.$('btnReset').onclick=()=>this.reset();
        this.$('btnCreateDemo').onclick=()=>this.createDemoData();

        this.$('speed').addEventListener('input',e=>{
          this.speed=Number(e.target.value)||1; 
          this.$('speedVal').textContent=this.speed.toFixed(1)+'x';
        });
        
        this.$('toggleTrails').addEventListener('change',e=>{
          this.showTrails=e.target.checked;
          if (!this.showTrails) {
            this.trailsLines.forEach(line => { this.scene?.remove(line); line.geometry?.dispose(); });
            this.trailsLines.clear();
            this.trails.clear();
          }
        });
        
        this.$('toggleBounds').addEventListener('change',e=>{
          this.showBounds=e.target.checked;
          if(this.fieldGroup) this.fieldGroup.visible=this.showBounds;
        });

        this.$('toggleProjectiles').addEventListener('change',e=>{
          this.showProjectiles=e.target.checked;
        });

        this.$('frame').addEventListener('input',e=>{
          this.cur = Math.min(this.frames.length-1, Math.max(0, Number(e.target.value)||0));
          this.updateFrame(true);
        });

        document.querySelectorAll('[data-cam]').forEach(b=>{
          b.addEventListener('click',()=>this.setCam(b.dataset.cam));
        });
      }

      hookFile(){
        const input=this.$('fileInput');
        const drop =this.$('dropZone');
        
        input.onchange=(e)=>{ 
          if(e.target.files && e.target.files[0]) this.loadFile(e.target.files[0]); 
        };
        
        drop.addEventListener('click',()=>input.click());
        drop.addEventListener('dragover',e=>{e.preventDefault(); drop.classList.add('drag');});
        drop.addEventListener('dragleave',()=>drop.classList.remove('drag'));
        drop.addEventListener('drop',e=>{
          e.preventDefault(); drop.classList.remove('drag');
          const f=e.dataTransfer.files && e.dataTransfer.files[0]; 
          if(f) this.loadFile(f);
        });
      }

      async loadFile(file){
        try {
          console.log(`üìÇ Loading battle file: ${file.name}`);
          const txt = await file.text();
          const json = JSON.parse(txt);
          
          console.log(`‚úÖ File loaded successfully:`);
          console.log(`   Battle ID: ${json.battle_id || 'Unknown'}`);
          console.log(`   Frames: ${json.frames?.length || 0}`);
          console.log(`   Teams: ${json.red_team_size || 0}v${json.blue_team_size || 0}`);
          
          this.ingest(json);
        } catch(e) { 
          console.error(`‚ùå Failed to load file: ${file.name}`, e);
          alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª: ' + e.message); 
        }
      }

      createDemoData() {
        console.log("üéÆ Creating demo battle data...");
        
        const demoData = {
          battle_id: "demo_battle_3d_" + Date.now(),
          start_time: Date.now() / 1000,
          end_time: Date.now() / 1000 + 12,
          red_team_size: 2,
          blue_team_size: 2,
          winner: "red",
          field_bounds: {x_min: -10, x_max: 10, y_min: -8, y_max: 8, z_min: 0, z_max: 6},
          laser_config: {max_range: 8, damage: 15},
          boundary_deaths: 0,
          frames: []
        };

        for (let i = 0; i < 60; i++) {
          const frame = {
            timestamp: demoData.start_time + i * 0.2,
            step: i,
            field_bounds: demoData.field_bounds,
            laser_config: demoData.laser_config,
            events: [],
            global_state: {},
            robots: [
              { id:"red_0",team:"red",
                x:-5+Math.sin(i*0.1)*2, y:-2+Math.cos(i*0.15)*1.5, z:2+Math.sin(i*0.2)*1,
                hp:Math.max(0,100-i*1.5), alive:100-i*1.5>0, within_bounds:true,
                target_enemy:0, move_action:[0.1,0.05,0.02], aim_action:[0.2,-0.1,0.0],
                fire_action: i%15===0, laser_range:8.0, can_shoot_targets:["blue_0","blue_1"] },
              { id:"red_1",team:"red",
                x:-3+Math.cos(i*0.12)*1.5, y:1+Math.sin(i*0.18)*2, z:1.5+Math.cos(i*0.25)*0.8,
                hp:Math.max(0,100-i*1.2), alive:100-i*1.2>0, within_bounds:true,
                target_enemy:1, move_action:[-0.05,0.1,-0.01], aim_action:[-0.15,0.2,0.05],
                fire_action: i%18===0, laser_range:8.0, can_shoot_targets:["blue_0"] },
              { id:"blue_0",team:"blue",
                x:5+Math.sin(i*0.11)*-1.8, y:2+Math.cos(i*0.16)*-1.2, z:2.5+Math.sin(i*0.22)*0.9,
                hp:Math.max(0,100-i*2.0), alive:100-i*2.0>0, within_bounds:true,
                target_enemy:0, move_action:[-0.1,-0.08,0.03], aim_action:[-0.25,0.15,-0.02],
                fire_action: i%12===0, laser_range:8.0, can_shoot_targets:["red_0","red_1"] },
              { id:"blue_1",team:"blue",
                x:3+Math.cos(i*0.13)*-2.2, y:-1+Math.sin(i*0.14)*-1.8, z:1.8+Math.cos(i*0.28)*1.1,
                hp:Math.max(0,100-i*1.8), alive:100-i*1.8>0, within_bounds:true,
                target_enemy:1, move_action:[0.08,-0.12,-0.02], aim_action:[0.18,-0.22,0.08],
                fire_action: i%20===0, laser_range:8.0, can_shoot_targets:["red_1"] }
            ]
          };
          
          // Add firing events
          frame.robots.forEach(robot => {
            if (robot.fire_action && robot.alive) {
              frame.events.push({
                type:"fire",
                timestamp:frame.timestamp,
                robot_id:robot.id,
                target_id:null,
                position:[robot.x, robot.y, robot.z],
                distance:8.5,
                success:Math.random() > 0.3
              });
            }
          });
          
          demoData.frames.push(frame);
        }
        
        console.log(`‚úÖ Demo data created: ${demoData.frames.length} frames`);
        this.ingest(demoData);
      }

      ingest(json){
        // –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π –Ω–æ–≤–æ–≥–æ –±–æ—è
        this.clearBattle();
        
        this.data = json;
        this.frames = Array.isArray(json.frames) ? json.frames : [];
        this.bounds = json.field_bounds || (this.frames[0]?.field_bounds) || {x_min:-10,x_max:10,y_min:-8,y_max:8,z_min:0,z_max:6};
        this.laser = json.laser_config || {max_range:8,damage:15,accuracy_falloff:0.1};

        this.$('tot').textContent = this.frames.length;
        this.$('frame').max = this.frames.length ? (this.frames.length-1) : 0;
        this.$('hint').classList.add('hidden');

        // –°–±—Ä–æ—Å –≤—Å–µ—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π
        this.robots.clear();
        this.trails.clear();
        this.trailsLines.forEach(line => { this.scene?.remove(line); line.geometry?.dispose(); });
        this.trailsLines.clear();
        
        // –û—á–∏—Å—Ç–∫–∞ —Å–Ω–∞—Ä—è–¥–æ–≤
        this.projectiles.forEach(proj => proj.destroy());
        this.projectiles.clear();
        
        // –°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        this.battleStats = { shotsFired: 0, shotsHit: 0 };
        this.recent = [];
        this.updateBattleStatsUI();

        if (this.scene) this.updateField();
        this.pause(); 
        this.cur = 0; 
        this.updateFrame(true);
      }

      clearBattle() {
        // """–ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–π –±–æ–π"""
        console.log("üßπ Clearing battle scene...");
        
        if (!this.scene) return;
        
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ—Ö —Ä–æ–±–æ—Ç–æ–≤ –∏–∑ —Å—Ü–µ–Ω—ã
        this.robots.forEach((robotGroup, robotId) => {
          console.log(`Removing robot: ${robotId}`);
          this.scene.remove(robotGroup);
          
          // –û—á–∏—â–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é –∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã
          robotGroup.traverse((child) => {
            if (child.geometry) {
              child.geometry.dispose();
            }
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(material => material.dispose());
              } else {
                child.material.dispose();
              }
            }
          });
        });
        this.robots.clear();
        
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–ª–µ–¥—ã
        this.trailsLines.forEach((line, robotId) => {
          console.log(`Removing trail: ${robotId}`);
          this.scene.remove(line);
          if (line.geometry) line.geometry.dispose();
          if (line.material) line.material.dispose();
        });
        this.trailsLines.clear();
        this.trails.clear();
        
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–Ω–∞—Ä—è–¥—ã
        this.projectiles.forEach(projectile => {
          console.log(`Removing projectile: ${projectile.constructor.name}`);
          projectile.destroy();
        });
        this.projectiles.clear();
        
        // –û—á–∏—â–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã (–ª–∞–∑–µ—Ä—ã, –≤–∑—Ä—ã–≤—ã –∏ —Ç.–¥.)
        const objectsToRemove = [];
        this.scene.children.forEach(child => {
          // –£–¥–∞–ª—è–µ–º –æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —è–≤–ª—è—é—Ç—Å—è –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏ —Å—Ü–µ–Ω—ã
          if (child !== this.fieldGroup && 
              !child.isLight && 
              !child.isAmbientLight && 
              !child.isDirectionalLight &&
              child.type !== 'GridHelper') {
            objectsToRemove.push(child);
          }
        });
        
        objectsToRemove.forEach(obj => {
          console.log(`Removing scene object: ${obj.type || 'Unknown'}`);
          this.scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(material => material.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
        
        // –°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
        this.followId = null;
        
        // –û—á–∏—â–∞–µ–º recent —Å–æ–±—ã—Ç–∏—è
        this.recent = [];
        
        console.log("‚úÖ Battle scene cleared");
      }

      init3D(){
        const cont = this.$('threejs-container');

        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x0b1020, 30, 80);

        const w=cont.clientWidth||800, h=cont.clientHeight||600;
        this.camera = new THREE.PerspectiveCamera(60, w/h, 0.1, 500);
        this.camera.position.set(18, 14, 18);

        this.renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
        this.renderer.setPixelRatio(window.devicePixelRatio||1);
        this.renderer.setSize(w,h);
        this.renderer.setClearColor(0x071019,1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        cont.innerHTML='';
        cont.appendChild(this.renderer.domElement);

        this.renderer.domElement.style.touchAction = 'none';
        this.renderer.domElement.tabIndex = 0;
        this.renderer.domElement.addEventListener('contextmenu', e=> e.preventDefault());

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping=true; 
        this.controls.dampingFactor=.08;
        this.controls.minDistance=4; 
        this.controls.maxDistance=80;
        this.controls.maxPolarAngle = Math.PI * 0.9;

        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambient);
        
        const directional = new THREE.DirectionalLight(0xffffff, 0.8);
        directional.position.set(16, 24, 12);
        directional.castShadow = true;
        directional.shadow.mapSize.width = 2048;
        directional.shadow.mapSize.height = 2048;
        this.scene.add(directional);

        this.fieldGroup = new THREE.Group();
        this.scene.add(this.fieldGroup);
        this.buildField();

        this.renderer.domElement.addEventListener('click', e => this.onClick(e));

        const onResize = () => {
          const w = cont.clientWidth, h = cont.clientHeight;
          this.camera.aspect = w / h;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(w, h);
        };
        window.addEventListener('resize', onResize);

        this.lastTime = 0;
        const animate = (currentTime) => {
          requestAnimationFrame(animate);
          
          const deltaTime = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;
          
          this.controls.update();
          
          if (this.showTrails && this.trails.size) this.updateTrails();
          
          // Update projectiles
          if (this.showProjectiles) {
            this.updateProjectiles(deltaTime);
          }

          if (this.followId && this.robots.has(this.followId)) {
            const robotGroup = this.robots.get(this.followId);
            const offset = new THREE.Vector3(4, 3, 6);
            const targetPos = robotGroup.position.clone().add(offset);
            this.camera.position.lerp(targetPos, 0.05);
            this.controls.target.lerp(robotGroup.position, 0.1);
          }
          this.renderer.render(this.scene, this.camera);
        };
        animate(0);
      }

      updateProjectiles(deltaTime) {
        const projectilesToRemove = [];
        
        this.projectiles.forEach(projectile => {
          if (!projectile.update(deltaTime)) {
            projectilesToRemove.push(projectile);
          }
        });
        
        projectilesToRemove.forEach(projectile => {
          this.projectiles.delete(projectile);
          projectile.destroy();
        });
      }

      buildField(){
        if (!this.bounds || !this.scene) return;
        this.fieldGroup.clear();
        
        const b = this.bounds;
        const W = b.x_max - b.x_min;
        const H = b.y_max - b.y_min; 
        const D = b.z_max - b.z_min;
        const centerX = (b.x_min + b.x_max) / 2;
        const centerY = (b.y_min + b.y_max) / 2;
        const centerZ = (b.z_min + b.z_max) / 2;

        const planeGeometry = new THREE.PlaneGeometry(W, H);
        const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x0b2a3a, transparent: true, opacity: 0.3 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(centerX, b.z_min, centerY);
        plane.receiveShadow = true;
        this.fieldGroup.add(plane);

        const gridHelper = new THREE.GridHelper(Math.max(W, H), 20, 0x274c77, 0x1a3a5c);
        gridHelper.position.set(centerX, b.z_min + 0.01, centerY);
        this.fieldGroup.add(gridHelper);

        const boxGeometry = new THREE.BoxGeometry(W, D, H);
        const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x3b82f6, wireframe: true, transparent: true, opacity: 0.6 });
        const boxHelper = new THREE.Mesh(boxGeometry, boxMaterial);
        boxHelper.position.set(centerX, centerZ, centerY);
        this.fieldGroup.add(boxHelper);

        const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
        const cornerGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const corners = [
          [b.x_min, b.z_min, b.y_min], [b.x_max, b.z_min, b.y_min],
          [b.x_min, b.z_min, b.y_max], [b.x_max, b.z_min, b.y_max],
          [b.x_min, b.z_max, b.y_min], [b.x_max, b.z_max, b.y_min],
          [b.x_min, b.z_max, b.y_max], [b.x_max, b.z_max, b.y_max]
        ];
        corners.forEach(([x, y, z]) => {
          const corner = new THREE.Mesh(cornerGeometry, cornerMaterial);
          corner.position.set(x, y, z);
          this.fieldGroup.add(corner);
        });

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4ade80 });
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(centerX, b.z_min, b.y_min),
          new THREE.Vector3(centerX, b.z_min, b.y_max)
        ]);
        const centerLine = new THREE.Line(lineGeometry, lineMaterial);
        this.fieldGroup.add(centerLine);

        this.fieldGroup.visible = this.showBounds;
      }

      updateField() {
        if (this.fieldGroup && this.bounds) this.buildField();
      }

      createRobotMesh(data){
        const group = new THREE.Group(); group.name = data.id;

        const bodyGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.8);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: data.team === 'red' ? 0xff5757 : 0x5b8dff, metalness: 0.2, roughness: 0.4 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.3; body.castShadow = true; body.receiveShadow = true; group.add(body);

        const headGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.3, 8);
        const headMaterial = new THREE.MeshStandardMaterial({ color: data.team === 'red' ? 0xcc4444 : 0x4477cc, metalness: 0.3, roughness: 0.3 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 0.75; head.castShadow = true; group.add(head);

        const gunGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.8, 8);
        const gunMaterial = new THREE.MeshStandardMaterial({ color: 0xffe066, emissive: 0x332200, emissiveIntensity: 0.3, metalness: 0.7, roughness: 0.2 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.rotation.z = Math.PI / 2; gun.position.set(0.6, 0.4, 0); gun.name = 'gun'; gun.castShadow = true; group.add(gun);

        const hpBgGeometry = new THREE.PlaneGeometry(1.0, 0.1);
        const hpBgMaterial = new THREE.MeshBasicMaterial({ color: 0x334155, transparent: true, opacity: 0.8 });
        const hpBg = new THREE.Mesh(hpBgGeometry, hpBgMaterial);
        hpBg.position.set(0, 1.2, 0); hpBg.name = 'hpBg'; group.add(hpBg);

        const hpGeometry = new THREE.PlaneGeometry(1.0, 0.1);
        const hpMaterial = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.9 });
        const hp = new THREE.Mesh(hpGeometry, hpMaterial);
        hp.position.set(0, 1.2, 0.01); hp.name = 'hp'; group.add(hp);

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 64;
        context.fillStyle = 'rgba(0, 0, 0, 0.7)'; context.fillRect(0, 0, 256, 64);
        context.fillStyle = data.team === 'red' ? '#ff5757' : '#5b8dff';
        context.font = '24px Arial'; context.textAlign = 'center';
        context.fillText(data.id, 128, 40);
        const labelTexture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true, alphaTest: 0.1 });
        const labelGeometry = new THREE.PlaneGeometry(1.5, 0.4);
        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        label.position.set(0, 1.6, 0); label.name = 'label'; group.add(label);

        group.userData = { selected:false, team:data.team };
        return group;
      }

      updateRobotMesh(group, data){
        if (!group || !data) return;
        group.position.set(data.x || 0, data.z || 2, data.y || 0);

        const hp = group.getObjectByName('hp');
        if (hp) {
          const hpPercent = Math.max(0, Math.min(1, (data.hp || 0) / 100));
          hp.scale.x = hpPercent;
          hp.position.x = (hpPercent - 1) * 0.5;
          if (hpPercent > 0.6) hp.material.color.setHex(0x22c55e);
          else if (hpPercent > 0.3) hp.material.color.setHex(0xf59e0b);
          else hp.material.color.setHex(0xef4444);
        }

        const scaleAlive = data.alive ? 1 : 0.7;
        group.scale.set(scaleAlive, scaleAlive, scaleAlive);

        const body = group.children.find(c => c.geometry instanceof THREE.BoxGeometry);
        const head = group.children.find(c => c.geometry instanceof THREE.CylinderGeometry);
        if (body && head) {
          if (!data.within_bounds || !data.alive) {
            body.material.color.setHex(data.team === 'red' ? 0x884444 : 0x444488);
            head.material.color.setHex(data.team === 'red' ? 0x662222 : 0x222266);
          } else {
            body.material.color.setHex(data.team === 'red' ? 0xff5757 : 0x5b8dff);
            head.material.color.setHex(data.team === 'red' ? 0xcc4444 : 0x4477cc);
          }
        }

        const gun = group.getObjectByName('gun');
        if (gun && data.aim_action && Array.isArray(data.aim_action)) {
          const [aimX, aimY, aimZ] = data.aim_action;
          gun.rotation.y = Math.atan2(aimX || 0, aimZ || 0);
          gun.rotation.x = -(aimY || 0) * 0.5;
        }

        if (this.showTrails && data.alive) {
          if (!this.trails.has(data.id)) this.trails.set(data.id, []);
          const trail = this.trails.get(data.id);
          const currentPos = new THREE.Vector3(group.position.x, group.position.y + 0.1, group.position.z);
          if (trail.length === 0 || currentPos.distanceTo(trail[trail.length - 1]) > 0.1) {
            trail.push(currentPos);
            if (trail.length > 100) trail.shift();
          }
        }

        // Create laser projectile when firing
        if (data.fire_action && data.alive && this.showProjectiles) {
          this.createLaserProjectile(group.position, data);
        }
      }

      createLaserProjectile(shooterPos, robotData) {
        this.battleStats.shotsFired++;
        this.updateBattleStatsUI();

        // Find target robot
        const frame = this.frames[this.cur];
        if (!frame) return;

        const enemyRobots = frame.robots.filter(r => 
          r.team !== robotData.team && r.alive
        );

        if (enemyRobots.length === 0) return;

        // Choose target (closest enemy for simplicity)
        let targetRobot = enemyRobots[0];
        let minDistance = Infinity;

        enemyRobots.forEach(enemy => {
          const distance = Math.sqrt(
            Math.pow(shooterPos.x - enemy.x, 2) +
            Math.pow(shooterPos.z - enemy.z, 2) +
            Math.pow(shooterPos.y - enemy.y, 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            targetRobot = enemy;
          }
        });

        const startPos = new THREE.Vector3(shooterPos.x, shooterPos.y + 0.4, shooterPos.z);
        const targetPos = new THREE.Vector3(targetRobot.x, targetRobot.z + 0.4, targetRobot.y);

        const projectile = new LaserProjectile(startPos, targetPos, robotData, this.scene, this);
        this.projectiles.add(projectile);
      }

      updateTrails(){
        if (!this.showTrails) return;
        for (const [robotId, points] of this.trails.entries()) {
          if (points.length < 2) continue;
          let trailLine = this.trailsLines.get(robotId);
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          if (!trailLine) {
            const robot = this.robots.get(robotId);
            const isRed = robot?.userData?.team === 'red';
            const color = isRed ? 0xff9999 : 0x9999ff;
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
            trailLine = new THREE.Line(geometry, material);
            this.trailsLines.set(robotId, trailLine);
            this.scene.add(trailLine);
          } else {
            trailLine.geometry.dispose();
            trailLine.geometry = geometry;
          }
        }
      }

      updateFrame(syncSlider = false){
        if (!this.frames.length || !this.scene) return;
        const frame = this.frames[this.cur]; if (!frame) return;

        const currentRobotIds = new Set((frame.robots || []).map(r => r.id));
        
        // –£–¥–∞–ª—è–µ–º —Ä–æ–±–æ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã—Ö –±–æ–ª—å—à–µ –Ω–µ—Ç –≤ —Ç–µ–∫—É—â–µ–º –∫–∞–¥—Ä–µ
        const robotsToRemove = [];
        this.robots.forEach((robotGroup, robotId) => {
          if (!currentRobotIds.has(robotId)) {
            robotsToRemove.push(robotId);
          }
        });
        
        robotsToRemove.forEach(robotId => {
          console.log(`Removing robot not in current frame: ${robotId}`);
          const robotGroup = this.robots.get(robotId);
          this.scene.remove(robotGroup);
          
          // –û—á–∏—â–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é –∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã
          robotGroup.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(material => material.dispose());
              } else {
                child.material.dispose();
              }
            }
          });
          
          this.robots.delete(robotId);
          
          // –£–¥–∞–ª—è–µ–º —Å–ª–µ–¥—ã —ç—Ç–æ–≥–æ —Ä–æ–±–æ—Ç–∞
          if (this.trailsLines.has(robotId)) {
            const trailLine = this.trailsLines.get(robotId);
            this.scene.remove(trailLine);
            if (trailLine.geometry) trailLine.geometry.dispose();
            if (trailLine.material) trailLine.material.dispose();
            this.trailsLines.delete(robotId);
          }
          if (this.trails.has(robotId)) {
            this.trails.delete(robotId);
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º —Ä–æ–±–æ—Ç–æ–≤ –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞
        (frame.robots || []).forEach(robotData => {
          let robotGroup = this.robots.get(robotData.id);
          if (!robotGroup) {
            console.log(`Creating new robot: ${robotData.id}`);
            robotGroup = this.createRobotMesh(robotData);
            this.scene.add(robotGroup);
            this.robots.set(robotData.id, robotGroup);
          }
          this.updateRobotMesh(robotGroup, robotData);
        });

        this.updateBattleStats(frame.robots || []);
        const startTime = this.data?.start_time || 0;
        const currentTime = (frame.timestamp || 0) - startTime;
        this.$('battleTime').textContent = (currentTime > 0 ? currentTime.toFixed(1) : '0') + 's';

        if (syncSlider) { this.$('cur').textContent = this.cur; this.$('frame').value = this.cur; }
        this.renderEvents(frame.events || []);
      }

      updateBattleStats(robots) {
        let redHP = 0, blueHP = 0, alive = 0;
        robots.forEach(robot => {
          if (robot.alive) {
            alive++;
            if (robot.team === 'red') redHP += robot.hp || 0;
            else if (robot.team === 'blue') blueHP += robot.hp || 0;
          }
        });
        this.$('redHP').textContent = Math.round(redHP);
        this.$('blueHP').textContent = Math.round(blueHP);
        this.$('aliveCount').textContent = alive;
      }

      renderEvents(events){
        if (!events || !events.length) {
          if (this.recent.length === 0) {
            this.$('events').textContent = '–°–æ–±—ã—Ç–∏–π –ø–æ–∫–∞ –Ω–µ—Ç';
            return;
          }
          events = this.recent.slice(-8);
        }
        
        const allEvents = [...events, ...this.recent].slice(-8).reverse();
        const html = allEvents.map(event => {
          const type = event.type || 'event';
          const robotId = event.robot_id || event.robot || event.shooter || '';
          const targetId = event.target_id || event.target ? ` ‚Üí ${event.target_id || event.target}` : '';
          const distance = (event.distance != null) ? ` ‚Ä¢ d=${Number(event.distance).toFixed(2)}` : '';
          const success = event.success ? ' ‚úÖ' : (event.success === false ? ' ‚ùå' : '');
          
          let icon = '';
          switch(type) {
            case 'fire': icon = 'üî•'; break;
            case 'hit': icon = 'üí•'; break;
            case 'laser_miss': icon = '‚≠ï'; break;
            default: icon = 'üì°';
          }
          
          return `<div class="kv"><span>${icon} ${type}${success}</span><span class="mono">${robotId}${targetId}${distance}</span></div>`;
        }).join('');
        this.$('events').innerHTML = html;
      }

      onClick(event){
        const rect = this.renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
          ((event.clientX - rect.left) / rect.width) * 2 - 1,
          -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);
        const robotGroups = Array.from(this.robots.values());
        const intersects = raycaster.intersectObjects(robotGroups, true);
        if (intersects.length > 0) {
          let targetGroup = intersects[0].object;
          while (targetGroup.parent && !this.robots.has(targetGroup.name)) {
            targetGroup = targetGroup.parent;
          }
          if (this.robots.has(targetGroup.name)) {
            this.selectRobot(targetGroup.name);
          }
        }
      }

      selectRobot(robotId) {
        this.robots.forEach(group => { group.userData.selected = false; });
        const robotGroup = this.robots.get(robotId);
        if (robotGroup) {
          robotGroup.userData.selected = true;
          this.followId = robotId;
          const frame = this.frames[this.cur];
          const robotData = frame?.robots?.find(r => r.id === robotId);
          if (robotData) {
            const accuracy = this.calculateRobotAccuracy(robotData);
            const info = `
              <div class="kv"><span>ID</span><span class="mono">${robotData.id}</span></div>
              <div class="kv"><span>–ö–æ–º–∞–Ω–¥–∞</span><span style="color: ${robotData.team === 'red' ? '#ff5757' : '#5b8dff'}">${robotData.team}</span></div>
              <div class="kv"><span>HP</span><span>${Math.round(robotData.hp || 0)}/100</span></div>
              <div class="kv"><span>–ü–æ–∑–∏—Ü–∏—è</span><span class="mono">[${robotData.x?.toFixed(1)}, ${robotData.y?.toFixed(1)}, ${robotData.z?.toFixed(1)}]</span></div>
              <div class="kv"><span>–ñ–∏–≤</span><span>${robotData.alive ? '‚úÖ' : '‚ùå'}</span></div>
              <div class="kv"><span>–í –≥—Ä–∞–Ω–∏—Ü–∞—Ö</span><span>${robotData.within_bounds ? '‚úÖ' : '‚ùå'}</span></div>
              <div class="kv"><span>–¢–æ—á–Ω–æ—Å—Ç—å</span><span>${(accuracy * 100).toFixed(1)}%</span></div>
              <div class="kv"><span>–¶–µ–ª—å</span><span>${robotData.target_enemy}</span></div>
              <div class="kv"><span>–û–≥–æ–Ω—å</span><span>${robotData.fire_action ? 'üî•' : '‚≠ï'}</span></div>
              <div class="kv"><span>–°–ª–µ–¥–æ–≤–∞–Ω–∏–µ</span><span>ON</span></div>
            `;
            this.$('robotInfo').innerHTML = info;
          }
        }
      }

      calculateRobotAccuracy(robotData) {
        if (!robotData.aim_action) return 0.8;
        
        const aimVector = new THREE.Vector3(
          robotData.aim_action[0] || 0,
          robotData.aim_action[1] || 0,
          robotData.aim_action[2] || 0
        );
        
        const aimMagnitude = aimVector.length();
        const baseAccuracy = 0.9;
        const aimPenalty = Math.min(0.5, aimMagnitude * 0.3);
        
        return Math.max(0.2, baseAccuracy - aimPenalty);
      }

      setCam(preset){
        if (!this.bounds || !this.camera || !this.controls) return;
        const centerX = (this.bounds.x_min + this.bounds.x_max) / 2;
        const centerY = (this.bounds.y_min + this.bounds.y_max) / 2;
        const centerZ = (this.bounds.z_min + this.bounds.z_max) / 2;
        const target = new THREE.Vector3(centerX, centerZ, centerY);
        switch (preset) {
          case 'overview':
            this.camera.position.set(centerX + 20, centerZ + 16, centerY + 20);
            this.controls.target.copy(target); this.followId = null; break;
          case 'side':
            this.camera.position.set(centerX + 25, centerZ + 8, centerY);
            this.controls.target.copy(target); this.followId = null; break;
          case 'top':
            this.camera.position.set(centerX, centerZ + 30, centerY);
            this.controls.target.copy(target); this.followId = null; break;
          case 'follow':
            if (this.followId && this.robots.has(this.followId)) {
              const robotGroup = this.robots.get(this.followId);
              const offset = new THREE.Vector3(5, 4, 8);
              this.camera.position.copy(robotGroup.position).add(offset);
              this.controls.target.copy(robotGroup.position);
            } else if (this.robots.size > 0) {
              const firstRobot = this.robots.values().next().value;
              this.followId = firstRobot.name;
              this.selectRobot(this.followId);
            }
            break;
        }
        this.controls.update();
      }

      play(){
        if (!this.frames.length || this.isPlay) return;
        this.isPlay = true;
        const step = () => {
          if (!this.isPlay) return;
          if (this.cur < this.frames.length - 1) {
            this.cur++; this.updateFrame(true);
            const delay = Math.max(50, 150 / this.speed);
            setTimeout(step, delay);
          } else { this.isPlay = false; }
        };
        step();
      }

      pause(){ this.isPlay = false; }

      reset(){
        this.pause(); 
        
        // –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–µ—Ä–µ–¥ —Å–±—Ä–æ—Å–æ–º
        this.clearBattle();
        
        this.cur = 0; 
        this.updateFrame(true);
        
        // –°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã –∫ –æ–±–∑–æ—Ä–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
        if (this.bounds && this.camera && this.controls) {
          const centerX = (this.bounds.x_min + this.bounds.x_max) / 2;
          const centerY = (this.bounds.y_min + this.bounds.y_max) / 2;
          const centerZ = (this.bounds.z_min + this.bounds.z_max) / 2;
          this.camera.position.set(centerX + 20, centerZ + 16, centerY + 20);
          this.controls.target.set(centerX, centerZ, centerY);
          this.controls.update();
        }
        
        console.log("üîÑ Battle reset completed");
      }
    }

    window.addEventListener('load', () => {
      window.visualizer = new Visualizer();
    });

    window.debugVis = {
      createTestRobot: () => {
        const v = window.visualizer; if (!v || !v.scene) return;
        const testData = { id:"test_robot", team:"red", x:0, y:0, z:2, hp:75, alive:true, within_bounds:true,
          target_enemy:0, move_action:[0.1,0.0,0.0], aim_action:[1.0,0.0,0.0], fire_action:false };
        const robot = v.createRobotMesh(testData);
        v.scene.add(robot); v.robots.set("test_robot", robot);
        v.updateRobotMesh(robot, testData);
      },
      logScene: () => {
        const v = window.visualizer; if (!v || !v.scene) return;
        console.log('Children:', v.scene.children.length);
        console.log('Robots:', v.robots.size);
        console.log('Projectiles:', v.projectiles.size);
        console.log('Current frame:', v.cur);
        console.log('Total frames:', v.frames.length);
        console.log('Battle stats:', v.battleStats);
      },
      fireLaser: () => {
        const v = window.visualizer; if (!v || !v.scene || !v.robots.size) return;
        const robot = v.robots.values().next().value;
        const testData = { 
          id: robot.name, team: robot.userData.team, 
          aim_action: [0.1, 0.0, 0.1], laser_range: 8.0,
          fire_action: true, alive: true
        };
        v.createLaserProjectile(robot.position, testData);
      }
    };
  </script>
</body>
</html>