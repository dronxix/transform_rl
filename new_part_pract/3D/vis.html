<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Arena 3D Battle Visualizer</title>
  <style>
    :root{ --bg:#0b0f1a;--bg2:#0e1424;--panel:#121b30;--panel2:#0f1a33; --text:#e5ecff;--muted:#94a3b8;--border:#1f2a44;--chip:#1b2540; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;padding:0;background:linear-gradient(135deg,var(--bg),var(--bg2));color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; overflow:hidden; }
    .wrap{display:flex;flex-direction:column;height:100%}
    header{ padding:14px 18px;border-bottom:1px solid var(--border);
      display:flex;gap:16px;align-items:center;justify-content:space-between;background:linear-gradient(180deg,#121b30,#0f1a33); position:relative;z-index:2; }
    header .ttl{display:flex;align-items:center;gap:10px}
    header h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.3px}
    header .sub{font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{background:#1a2644;border:1px solid var(--border);color:var(--text); padding:8px 12px;border-radius:10px;cursor:pointer;transition:all .15s ease;font-weight:600}
    .btn:hover{transform:translateY(-1px);box-shadow:0 4px 14px rgba(0,0,0,.25)}
    .btn.ok{background:#11351f;border-color:#1b8a52}
    .btn.danger{background:#381417;border-color:#7a1d27}
    .btn.warn{background:#3a2a14;border-color:#7c4a00}
    .chip{background:var(--chip);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px}
    .tog{display:flex;align-items:center;gap:8px}
    .tog input{transform:scale(1.2)}
    .speed{display:flex;align-items:center;gap:8px}
    .layout{display:flex;flex:1 1 auto;min-height:0}
    .viewer{position:relative;flex:1 1 auto;min-width:0}
    #threejs-container{position:absolute;inset:0;z-index:1}
    .overlay-hint{ position:absolute;left:50%;top:16px;transform:translateX(-50%);
      background:#0f172a88;padding:8px 12px;border:1px solid var(--border);border-radius:10px;font-size:12px; pointer-events:none; }
    .debug{position:absolute;top:50px;left:10px;background:rgba(0,0,0,0.8);color:#fff;padding:10px;border-radius:5px;font-size:12px;font-family:monospace}
    aside{ width:320px;max-width:35vw;border-left:1px solid var(--border);background:linear-gradient(180deg,#121b30,#0f1a33);
      display:flex;flex-direction:column;gap:12px;padding:12px;overflow:auto }
    .card{background:#0d142a;border:1px solid var(--border);border-radius:14px;padding:12px}
    .card h3{margin:0 0 6px;font-size:14px;letter-spacing:.3px}
    .row{display:flex;gap:10px}
    .stat{flex:1 1 0;background:#0c1326;border:1px solid var(--border);border-radius:12px;padding:10px;text-align:center}
    .stat .v{font-weight:800;font-size:20px}
    .stat.red{border-color:#7f1d1d}
    .stat.blue{border-color:#1d4ed8}
    .kv{display:flex;justify-content:space-between;padding:4px 0;color:var(--muted);font-size:12px}
    .timeline input[type=range]{width:100%}
    .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .robot-info{min-height:110px;max-height:180px;overflow:auto;font-size:12px}
    .drop{border:2px dashed #334155;border-radius:14px;background:#0b1226;padding:14px;text-align:center;cursor:pointer}
    .drop.drag{background:#0d1530;border-color:#64748b}
    .muted{color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .hidden{display:none !important}
    canvas{display:block;outline:none}
    @media (max-width: 1000px){aside{width:280px}}
    @media (max-width: 860px){
      .layout{flex-direction:column}
      aside{width:100%;max-width:none;height:40vh}
      .viewer{height:60vh}
    }
  </style>
</head>
<body>
  <script>
    document.addEventListener('dragover', e => e.preventDefault(), false);
    document.addEventListener('drop', e => e.preventDefault(), false);
  </script>

  <div class="wrap">
    <header>
      <div class="ttl">
        <div style="font-size:20px">üõ∞Ô∏è</div>
        <div>
          <h1>Arena 3D Battle Visualizer</h1>
          <div class="sub">3D-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—ë–≤ —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –ø–æ–ª—è –∏ —Ä–∞–¥–∏—É—Å–æ–º –ª–∞–∑–µ—Ä–∞</div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å JSON –±–æ—è</button>
        <input type="file" id="fileInput" accept=".json" class="hidden"/>
        <button class="btn ok" id="btnPlay">‚ñ∂ –ü—É—Å–∫</button>
        <button class="btn" id="btnPause">‚è∏ –ü–∞—É–∑–∞</button>
        <button class="btn danger" id="btnReset">‚ü≤ –°–±—Ä–æ—Å</button>
        <span class="speed">
          <span>–°–∫–æ—Ä–æ—Å—Ç—å:</span>
          <input type="range" id="speed" min="0.2" max="3" step="0.1" value="1"/>
          <span id="speedVal" class="chip mono">1.0x</span>
        </span>
        <label class="tog"><input type="checkbox" id="toggleTrails" checked/><span>–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–ª–µ–¥—ã</span></label>
        <label class="tog"><input type="checkbox" id="toggleBounds" checked/><span>–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã</span></label>
        <button class="btn warn" id="btnDebug">üêõ –û—Ç–ª–∞–¥–∫–∞</button>
        <button class="btn" id="btnCreateDemo">üéÆ –î–µ–º–æ-–¥–∞–Ω–Ω—ã–µ</button>
      </div>
    </header>

    <div class="layout">
      <section class="viewer">
        <div id="threejs-container"></div>
        <div class="overlay-hint muted mono" id="hint">–ó–∞–≥—Ä—É–∑–∏—Ç–µ battle_3d_*.json –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ</div>
        <div class="debug hidden" id="debugInfo">
          –°–æ—Å—Ç–æ—è–Ω–∏–µ:<br>
          –°—Ü–µ–Ω–∞: <span id="sceneStatus">‚ùå</span><br>
          –î–∞–Ω–Ω—ã–µ: <span id="dataStatus">‚ùå</span><br>
          –ö–∞–¥—Ä–æ–≤: <span id="framesStatus">0</span><br>
          –¢–µ–∫—É—â–∏–π: <span id="currentStatus">0</span>
        </div>
      </section>

      <aside>
        <div class="card drop" id="dropZone">üìÅ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ JSON –±–æ—è —Å—é–¥–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</div>
        <div class="card">
          <h3>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—è</h3>
          <div class="row">
            <div class="stat red"><div>HP –∫–æ–º–∞–Ω–¥—ã Red</div><div class="v" id="redHP">0</div></div>
            <div class="stat blue"><div>HP –∫–æ–º–∞–Ω–¥—ã Blue</div><div class="v" id="blueHP">0</div></div>
          </div>
          <div class="row" style="margin-top:8px">
            <div class="stat"><div>–ñ–∏–≤—ã</div><div class="v" id="aliveCount">0</div></div>
            <div class="stat"><div>–í—Ä–µ–º—è</div><div class="v" id="battleTime">0s</div></div>
          </div>
        </div>
        <div class="card timeline">
          <h3>‚è∞ –®–∫–∞–ª–∞ –≤—Ä–µ–º–µ–Ω–∏</h3>
          <input type="range" id="frame" min="0" max="0" value="0"/>
          <div class="kv"><span>–ö–∞–¥—Ä: <span id="cur">0</span></span><span>–í—Å–µ–≥–æ: <span id="tot">0</span></span></div>
        </div>
        <div class="card">
          <h3>üì∑ –ö–∞–º–µ—Ä–∞</h3>
          <div class="grid">
            <button class="btn" data-cam="overview">üèüÔ∏è –û–±–∑–æ—Ä</button>
            <button class="btn" data-cam="side">üìê –°–±–æ–∫—É</button>
            <button class="btn" data-cam="top">‚¨áÔ∏è –°–≤–µ—Ä—Ö—É</button>
            <button class="btn" data-cam="follow">üéØ –°–ª–µ–¥–æ–≤–∞—Ç—å</button>
          </div>
          <div class="muted" style="margin-top:8px">üñ±Ô∏è –í—Ä–∞—â–µ–Ω–∏–µ/–ó—É–º ‚Ä¢ ‚§¢ –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞: –ü–∞–Ω–æ—Ä–∞–º–∞</div>
        </div>
        <div class="card">
          <h3>ü§ñ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–æ–±–æ—Ç–µ</h3>
          <div id="robotInfo" class="robot-info">–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —Ä–æ–±–æ—Ç—É, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–µ—Ç–∞–ª–∏</div>
        </div>
        <div class="card">
          <h3>üéûÔ∏è –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è</h3>
          <div id="events" class="robot-info">–°–æ–±—ã—Ç–∏–π –ø–æ–∫–∞ –Ω–µ—Ç</div>
        </div>
      </aside>
    </div>
  </div>

  <!-- –ú–û–î–£–õ–¨–ù–´–ô –°–ö–†–ò–ü–¢ –° –ü–†–Ø–ú–´–ú–ò –ü–£–¢–Ø–ú–ò -->
  <script type="module">
    import * as THREE from './libs/three-r152/build/three.module.js';
    import { OrbitControls } from './libs/three-r152/examples/jsm/controls/OrbitControls.js';

    window.debugMode = false;

    class Visualizer {
      constructor(){
        this.data=null; this.frames=[]; this.bounds=null; this.laser=null;
        this.cur=0; this.isPlay=false; this.speed=1; this.showBounds=true; this.showTrails=true;
        this.recent=[]; this.robots=new Map(); this.trails=new Map(); this.trailsLines=new Map(); this.followId=null;

        this.$=id=>document.getElementById(id);
        this.hookUI();
        this.hookFile();
        this.init3D();
      }

      updateDebugStatus() {
        if (!window.debugMode) return;
        this.$('sceneStatus').textContent = this.scene ? '‚úÖ' : '‚ùå';
        this.$('dataStatus').textContent = this.data ? '‚úÖ' : '‚ùå';
        this.$('framesStatus').textContent = this.frames.length;
        this.$('currentStatus').textContent = this.cur;
      }

      hookUI(){
        this.$('btnLoad').onclick=()=>this.$('fileInput').click();
        this.$('btnPlay').onclick=()=>this.play();
        this.$('btnPause').onclick=()=>this.pause();
        this.$('btnReset').onclick=()=>this.reset();
        this.$('btnDebug').onclick=()=>this.toggleDebug();
        this.$('btnCreateDemo').onclick=()=>this.createDemoData();

        this.$('speed').addEventListener('input',e=>{
          this.speed=Number(e.target.value)||1; 
          this.$('speedVal').textContent=this.speed.toFixed(1)+'x';
        });
        
        this.$('toggleTrails').addEventListener('change',e=>{
          this.showTrails=e.target.checked;
          if (!this.showTrails) {
            this.trailsLines.forEach(line => { this.scene?.remove(line); line.geometry?.dispose(); });
            this.trailsLines.clear();
            this.trails.clear();
          }
        });
        
        this.$('toggleBounds').addEventListener('change',e=>{
          this.showBounds=e.target.checked;
          if(this.fieldGroup) this.fieldGroup.visible=this.showBounds;
        });

        this.$('frame').addEventListener('input',e=>{
          this.cur = Math.min(this.frames.length-1, Math.max(0, Number(e.target.value)||0));
          this.updateFrame(true);
        });

        document.querySelectorAll('[data-cam]').forEach(b=>{
          b.addEventListener('click',()=>this.setCam(b.dataset.cam));
        });
      }

      toggleDebug() {
        window.debugMode = !window.debugMode;
        const debug = this.$('debugInfo');
        if (window.debugMode) {
          debug.classList.remove('hidden');
          this.updateDebugStatus();
          if (!this._dbgInterval) {
            this._dbgInterval = setInterval(() => this.updateDebugStatus(), 1000);
          }
        } else {
          debug.classList.add('hidden');
          if (this._dbgInterval){ clearInterval(this._dbgInterval); this._dbgInterval = null; }
        }
      }

      hookFile(){
        const input=this.$('fileInput');
        const drop =this.$('dropZone');
        
        input.onchange=(e)=>{ 
          if(e.target.files && e.target.files[0]) this.loadFile(e.target.files[0]); 
        };
        
        drop.addEventListener('click',()=>input.click());
        drop.addEventListener('dragover',e=>{e.preventDefault(); drop.classList.add('drag');});
        drop.addEventListener('dragleave',()=>drop.classList.remove('drag'));
        drop.addEventListener('drop',e=>{
          e.preventDefault(); drop.classList.remove('drag');
          const f=e.dataTransfer.files && e.dataTransfer.files[0]; 
          if(f) this.loadFile(f);
        });
      }

      async loadFile(file){
        try {
          const txt = await file.text();
          const json = JSON.parse(txt);
          this.ingest(json);
        } catch(e) { alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª: ' + e.message); }
      }

      createDemoData() {
        const demoData = {
          battle_id: "demo_battle_3d",
          start_time: Date.now() / 1000,
          end_time: Date.now() / 1000 + 10,
          red_team_size: 2,
          blue_team_size: 2,
          winner: "red",
          field_bounds: {x_min: -10, x_max: 10, y_min: -8, y_max: 8, z_min: 0, z_max: 6},
          laser_config: {max_range: 8, damage: 15},
          boundary_deaths: 0,
          frames: []
        };

        for (let i = 0; i < 50; i++) {
          const frame = {
            timestamp: demoData.start_time + i * 0.2,
            step: i,
            field_bounds: demoData.field_bounds,
            laser_config: demoData.laser_config,
            events: [],
            global_state: {},
            robots: [
              { id:"red_0",team:"red",
                x:-5+Math.sin(i*0.1)*2, y:-2+Math.cos(i*0.15)*1.5, z:2+Math.sin(i*0.2)*1,
                hp:Math.max(0,100-i*1.5), alive:100-i*1.5>0, within_bounds:true,
                target_enemy:0, move_action:[0.1,0.05,0.02], aim_action:[0.2,-0.1,0.0],
                fire_action: i%10===0, laser_range:8.0, can_shoot_targets:["blue_0","blue_1"] },
              { id:"red_1",team:"red",
                x:-3+Math.cos(i*0.12)*1.5, y:1+Math.sin(i*0.18)*2, z:1.5+Math.cos(i*0.25)*0.8,
                hp:Math.max(0,100-i*1.2), alive:100-i*1.2>0, within_bounds:true,
                target_enemy:1, move_action:[-0.05,0.1,-0.01], aim_action:[-0.15,0.2,0.05],
                fire_action: i%8===0, laser_range:8.0, can_shoot_targets:["blue_0"] },
              { id:"blue_0",team:"blue",
                x:5+Math.sin(i*0.11)*-1.8, y:2+Math.cos(i*0.16)*-1.2, z:2.5+Math.sin(i*0.22)*0.9,
                hp:Math.max(0,100-i*2.0), alive:100-i*2.0>0, within_bounds:true,
                target_enemy:0, move_action:[-0.1,-0.08,0.03], aim_action:[-0.25,0.15,-0.02],
                fire_action: i%12===0, laser_range:8.0, can_shoot_targets:["red_0","red_1"] },
              { id:"blue_1",team:"blue",
                x:3+Math.cos(i*0.13)*-2.2, y:-1+Math.sin(i*0.14)*-1.8, z:1.8+Math.cos(i*0.28)*1.1,
                hp:Math.max(0,100-i*1.8), alive:100-i*1.8>0, within_bounds:true,
                target_enemy:1, move_action:[0.08,-0.12,-0.02], aim_action:[0.18,-0.22,0.08],
                fire_action: i%15===0, laser_range:8.0, can_shoot_targets:["red_1"] }
            ]
          };
          if (i % 10 === 0) {
            frame.events.push({type:"fire",timestamp:frame.timestamp,robot_id:"red_0",target_id:"blue_0",
              position:[frame.robots[0].x,frame.robots[0].y,frame.robots[0].z],distance:8.5,success:true});
          }
          demoData.frames.push(frame);
        }
        this.ingest(demoData);
      }

      ingest(json){
        this.data = json;
        this.frames = Array.isArray(json.frames) ? json.frames : [];
        this.bounds = json.field_bounds || (this.frames[0]?.field_bounds) || {x_min:-10,x_max:10,y_min:-8,y_max:8,z_min:0,z_max:6};
        this.laser = json.laser_config || {max_range:8,damage:15,accuracy_falloff:0.1};

        this.$('tot').textContent = this.frames.length;
        this.$('frame').max = this.frames.length ? (this.frames.length-1) : 0;
        this.$('hint').classList.add('hidden');

        this.robots.clear();
        this.trails.clear();
        this.trailsLines.forEach(line => { this.scene?.remove(line); line.geometry?.dispose(); });
        this.trailsLines.clear();

        if (this.scene) this.updateField();
        this.pause(); this.cur = 0; this.updateFrame(true);
        this.$('dataStatus').textContent = '‚úÖ';
      }

      init3D(){
        const cont = this.$('threejs-container');

        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x0b1020, 30, 80);

        const w=cont.clientWidth||800, h=cont.clientHeight||600;
        this.camera = new THREE.PerspectiveCamera(60, w/h, 0.1, 500);
        this.camera.position.set(18, 14, 18);

        this.renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
        this.renderer.setPixelRatio(window.devicePixelRatio||1);
        this.renderer.setSize(w,h);
        this.renderer.setClearColor(0x071019,1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        cont.innerHTML='';
        cont.appendChild(this.renderer.domElement);

        this.renderer.domElement.style.touchAction = 'none';
        this.renderer.domElement.tabIndex = 0;
        this.renderer.domElement.addEventListener('contextmenu', e=> e.preventDefault());

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping=true; 
        this.controls.dampingFactor=.08;
        this.controls.minDistance=4; 
        this.controls.maxDistance=80;
        this.controls.maxPolarAngle = Math.PI * 0.9;

        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambient);
        
        const directional = new THREE.DirectionalLight(0xffffff, 0.8);
        directional.position.set(16, 24, 12);
        directional.castShadow = true;
        directional.shadow.mapSize.width = 2048;
        directional.shadow.mapSize.height = 2048;
        this.scene.add(directional);

        this.fieldGroup = new THREE.Group();
        this.scene.add(this.fieldGroup);
        this.buildField();

        this.renderer.domElement.addEventListener('click', e => this.onClick(e));

        const onResize = () => {
          const w = cont.clientWidth, h = cont.clientHeight;
          this.camera.aspect = w / h;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(w, h);
        };
        window.addEventListener('resize', onResize);

        const animate = () => {
          requestAnimationFrame(animate);
          this.controls.update();
          if (this.showTrails && this.trails.size) this.updateTrails();

          if (this.followId && this.robots.has(this.followId)) {
            const robotGroup = this.robots.get(this.followId);
            const offset = new THREE.Vector3(4, 3, 6);
            const targetPos = robotGroup.position.clone().add(offset);
            this.camera.position.lerp(targetPos, 0.05);
            this.controls.target.lerp(robotGroup.position, 0.1);
          }
          this.renderer.render(this.scene, this.camera);
        };
        animate();

        this.$('sceneStatus').textContent = '‚úÖ';
      }

      buildField(){
        if (!this.bounds || !this.scene) return;
        this.fieldGroup.clear();
        
        const b = this.bounds;
        const W = b.x_max - b.x_min;
        const H = b.y_max - b.y_min; 
        const D = b.z_max - b.z_min;
        const centerX = (b.x_min + b.x_max) / 2;
        const centerY = (b.y_min + b.y_max) / 2;
        const centerZ = (b.z_min + b.z_max) / 2;

        const planeGeometry = new THREE.PlaneGeometry(W, H);
        const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x0b2a3a, transparent: true, opacity: 0.3 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(centerX, b.z_min, centerY);
        plane.receiveShadow = true;
        this.fieldGroup.add(plane);

        const gridHelper = new THREE.GridHelper(Math.max(W, H), 20, 0x274c77, 0x1a3a5c);
        gridHelper.position.set(centerX, b.z_min + 0.01, centerY);
        this.fieldGroup.add(gridHelper);

        const boxGeometry = new THREE.BoxGeometry(W, D, H);
        const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x3b82f6, wireframe: true, transparent: true, opacity: 0.6 });
        const boxHelper = new THREE.Mesh(boxGeometry, boxMaterial);
        boxHelper.position.set(centerX, centerZ, centerY);
        this.fieldGroup.add(boxHelper);

        const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
        const cornerGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const corners = [
          [b.x_min, b.z_min, b.y_min], [b.x_max, b.z_min, b.y_min],
          [b.x_min, b.z_min, b.y_max], [b.x_max, b.z_min, b.y_max],
          [b.x_min, b.z_max, b.y_min], [b.x_max, b.z_max, b.y_min],
          [b.x_min, b.z_max, b.y_max], [b.x_max, b.z_max, b.y_max]
        ];
        corners.forEach(([x, y, z]) => {
          const corner = new THREE.Mesh(cornerGeometry, cornerMaterial);
          corner.position.set(x, y, z);
          this.fieldGroup.add(corner);
        });

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4ade80 });
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(centerX, b.z_min, b.y_min),
          new THREE.Vector3(centerX, b.z_min, b.y_max)
        ]);
        const centerLine = new THREE.Line(lineGeometry, lineMaterial);
        this.fieldGroup.add(centerLine);

        this.fieldGroup.visible = this.showBounds;
      }

      updateField() {
        if (this.fieldGroup && this.bounds) this.buildField();
      }

      createRobotMesh(data){
        const group = new THREE.Group(); group.name = data.id;

        const bodyGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.8);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: data.team === 'red' ? 0xff5757 : 0x5b8dff, metalness: 0.2, roughness: 0.4 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.3; body.castShadow = true; body.receiveShadow = true; group.add(body);

        const headGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.3, 8);
        const headMaterial = new THREE.MeshStandardMaterial({ color: data.team === 'red' ? 0xcc4444 : 0x4477cc, metalness: 0.3, roughness: 0.3 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 0.75; head.castShadow = true; group.add(head);

        const gunGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.8, 8);
        const gunMaterial = new THREE.MeshStandardMaterial({ color: 0xffe066, emissive: 0x332200, emissiveIntensity: 0.3, metalness: 0.7, roughness: 0.2 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.rotation.z = Math.PI / 2; gun.position.set(0.6, 0.4, 0); gun.name = 'gun'; gun.castShadow = true; group.add(gun);

        const hpBgGeometry = new THREE.PlaneGeometry(1.0, 0.1);
        const hpBgMaterial = new THREE.MeshBasicMaterial({ color: 0x334155, transparent: true, opacity: 0.8 });
        const hpBg = new THREE.Mesh(hpBgGeometry, hpBgMaterial);
        hpBg.position.set(0, 1.2, 0); hpBg.name = 'hpBg'; group.add(hpBg);

        const hpGeometry = new THREE.PlaneGeometry(1.0, 0.1);
        const hpMaterial = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.9 });
        const hp = new THREE.Mesh(hpGeometry, hpMaterial);
        hp.position.set(0, 1.2, 0.01); hp.name = 'hp'; group.add(hp);

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 64;
        context.fillStyle = 'rgba(0, 0, 0, 0.7)'; context.fillRect(0, 0, 256, 64);
        context.fillStyle = data.team === 'red' ? '#ff5757' : '#5b8dff';
        context.font = '24px Arial'; context.textAlign = 'center';
        context.fillText(data.id, 128, 40);
        const labelTexture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true, alphaTest: 0.1 });
        const labelGeometry = new THREE.PlaneGeometry(1.5, 0.4);
        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        label.position.set(0, 1.6, 0); label.name = 'label'; group.add(label);

        group.userData = { selected:false, team:data.team };
        return group;
      }

      updateRobotMesh(group, data){
        if (!group || !data) return;
        group.position.set(data.x || 0, data.z || 2, data.y || 0);

        const hp = group.getObjectByName('hp');
        if (hp) {
          const hpPercent = Math.max(0, Math.min(1, (data.hp || 0) / 100));
          hp.scale.x = hpPercent;
          hp.position.x = (hpPercent - 1) * 0.5;
          if (hpPercent > 0.6) hp.material.color.setHex(0x22c55e);
          else if (hpPercent > 0.3) hp.material.color.setHex(0xf59e0b);
          else hp.material.color.setHex(0xef4444);
        }

        const scaleAlive = data.alive ? 1 : 0.7;
        group.scale.set(scaleAlive, scaleAlive, scaleAlive);

        const body = group.children.find(c => c.geometry instanceof THREE.BoxGeometry);
        const head = group.children.find(c => c.geometry instanceof THREE.CylinderGeometry);
        if (body && head) {
          if (!data.within_bounds || !data.alive) {
            body.material.color.setHex(data.team === 'red' ? 0x884444 : 0x444488);
            head.material.color.setHex(data.team === 'red' ? 0x662222 : 0x222266);
          } else {
            body.material.color.setHex(data.team === 'red' ? 0xff5757 : 0x5b8dff);
            head.material.color.setHex(data.team === 'red' ? 0xcc4444 : 0x4477cc);
          }
        }

        const gun = group.getObjectByName('gun');
        if (gun && data.aim_action && Array.isArray(data.aim_action)) {
          const [aimX, aimY, aimZ] = data.aim_action;
          gun.rotation.y = Math.atan2(aimX || 0, aimZ || 0);
          gun.rotation.x = -(aimY || 0) * 0.5;
        }

        if (this.showTrails && data.alive) {
          if (!this.trails.has(data.id)) this.trails.set(data.id, []);
          const trail = this.trails.get(data.id);
          const currentPos = new THREE.Vector3(group.position.x, group.position.y + 0.1, group.position.z);
          if (trail.length === 0 || currentPos.distanceTo(trail[trail.length - 1]) > 0.1) {
            trail.push(currentPos);
            if (trail.length > 100) trail.shift();
          }
        }

        if (data.fire_action && data.alive) {
          this.createLaserEffect(group.position, data.aim_action || [1, 0, 0]);
        }
      }

      createLaserEffect(position, aimDirection) {
        const laserGeometry = new THREE.CylinderGeometry(0.02, 0.02, 8, 8);
        const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
        const laser = new THREE.Mesh(laserGeometry, laserMaterial);
        laser.position.copy(position); laser.position.y += 0.4;
        const [aimX, aimY, aimZ] = aimDirection || [1,0,0];
        const direction = new THREE.Vector3(aimX, aimY, aimZ).normalize();
        laser.lookAt(laser.position.clone().add(direction)); laser.rotateX(Math.PI / 2);
        this.scene.add(laser);
        let opacity = 0.8;
        const fadeOut = () => {
          opacity -= 0.05; laser.material.opacity = opacity;
          if (opacity <= 0) { this.scene.remove(laser); laser.geometry.dispose(); laser.material.dispose(); }
          else { requestAnimationFrame(fadeOut); }
        };
        setTimeout(fadeOut, 100);
      }

      updateTrails(){
        if (!this.showTrails) return;
        for (const [robotId, points] of this.trails.entries()) {
          if (points.length < 2) continue;
          let trailLine = this.trailsLines.get(robotId);
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          if (!trailLine) {
            const robot = this.robots.get(robotId);
            const isRed = robot?.userData?.team === 'red';
            const color = isRed ? 0xff9999 : 0x9999ff;
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
            trailLine = new THREE.Line(geometry, material);
            this.trailsLines.set(robotId, trailLine);
            this.scene.add(trailLine);
          } else {
            trailLine.geometry.dispose();
            trailLine.geometry = geometry;
          }
        }
      }

      updateFrame(syncSlider = false){
        if (!this.frames.length || !this.scene) return;
        const frame = this.frames[this.cur]; if (!frame) return;

        (frame.robots || []).forEach(robotData => {
          let robotGroup = this.robots.get(robotData.id);
          if (!robotGroup) {
            robotGroup = this.createRobotMesh(robotData);
            this.scene.add(robotGroup);
            this.robots.set(robotData.id, robotGroup);
          }
          this.updateRobotMesh(robotGroup, robotData);
        });

        const currentRobotIds = new Set((frame.robots || []).map(r => r.id));
        for (const [robotId, robotGroup] of this.robots.entries()) {
          if (!currentRobotIds.has(robotId)) {
            this.scene.remove(robotGroup);
            this.robots.delete(robotId);
          }
        }

        this.updateBattleStats(frame.robots || []);
        const startTime = this.data?.start_time || 0;
        const currentTime = (frame.timestamp || 0) - startTime;
        this.$('battleTime').textContent = (currentTime > 0 ? currentTime.toFixed(1) : '0') + 's';

        if (syncSlider) { this.$('cur').textContent = this.cur; this.$('frame').value = this.cur; }
        this.renderEvents(frame.events || []);
        this.updateDebugStatus();
      }

      updateBattleStats(robots) {
        let redHP = 0, blueHP = 0, alive = 0;
        robots.forEach(robot => {
          if (robot.alive) {
            alive++;
            if (robot.team === 'red') redHP += robot.hp || 0;
            else if (robot.team === 'blue') blueHP += robot.hp || 0;
          }
        });
        this.$('redHP').textContent = Math.round(redHP);
        this.$('blueHP').textContent = Math.round(blueHP);
        this.$('aliveCount').textContent = alive;
      }

      renderEvents(events){
        if (!events || !events.length) {
          this.$('events').textContent = '–°–æ–±—ã—Ç–∏–π –ø–æ–∫–∞ –Ω–µ—Ç';
          return;
        }
        const recentEvents = events.slice(-8).reverse();
        const html = recentEvents.map(event => {
          const type = event.type || 'event';
          const robotId = event.robot_id || event.robot || '';
          const targetId = event.target_id ? ` ‚Üí ${event.target_id}` : '';
          const distance = (event.distance != null) ? ` ‚Ä¢ d=${Number(event.distance).toFixed(2)}` : '';
          const success = event.success ? ' ‚úÖ' : (event.success === false ? ' ‚ùå' : '');
          return `<div class="kv"><span>${type}${success}</span><span class="mono">${robotId}${targetId}${distance}</span></div>`;
        }).join('');
        this.$('events').innerHTML = html;
      }

      onClick(event){
        const rect = this.renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
          ((event.clientX - rect.left) / rect.width) * 2 - 1,
          -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);
        const robotGroups = Array.from(this.robots.values());
        const intersects = raycaster.intersectObjects(robotGroups, true);
        if (intersects.length > 0) {
          let targetGroup = intersects[0].object;
          while (targetGroup.parent && !this.robots.has(targetGroup.name)) {
            targetGroup = targetGroup.parent;
          }
          if (this.robots.has(targetGroup.name)) {
            this.selectRobot(targetGroup.name);
          }
        }
      }

      selectRobot(robotId) {
        this.robots.forEach(group => { group.userData.selected = false; });
        const robotGroup = this.robots.get(robotId);
        if (robotGroup) {
          robotGroup.userData.selected = true;
          this.followId = robotId;
          const frame = this.frames[this.cur];
          const robotData = frame?.robots?.find(r => r.id === robotId);
          if (robotData) {
            const info = `
              <div class="kv"><span>ID</span><span class="mono">${robotData.id}</span></div>
              <div class="kv"><span>–ö–æ–º–∞–Ω–¥–∞</span><span style="color: ${robotData.team === 'red' ? '#ff5757' : '#5b8dff'}">${robotData.team}</span></div>
              <div class="kv"><span>HP</span><span>${Math.round(robotData.hp || 0)}/100</span></div>
              <div class="kv"><span>–ü–æ–∑–∏—Ü–∏—è</span><span class="mono">[${robotData.x?.toFixed(1)}, ${robotData.y?.toFixed(1)}, ${robotData.z?.toFixed(1)}]</span></div>
              <div class="kv"><span>–ñ–∏–≤</span><span>${robotData.alive ? '‚úÖ' : '‚ùå'}</span></div>
              <div class="kv"><span>–í –≥—Ä–∞–Ω–∏—Ü–∞—Ö</span><span>${robotData.within_bounds ? '‚úÖ' : '‚ùå'}</span></div>
              <div class="kv"><span>–¶–µ–ª—å</span><span>${robotData.target_enemy}</span></div>
              <div class="kv"><span>–û–≥–æ–Ω—å</span><span>${robotData.fire_action ? 'üî•' : '‚≠ï'}</span></div>
              <div class="kv"><span>–°–ª–µ–¥–æ–≤–∞–Ω–∏–µ</span><span>ON</span></div>
            `;
            this.$('robotInfo').innerHTML = info;
          }
        }
      }

      setCam(preset){
        if (!this.bounds || !this.camera || !this.controls) return;
        const centerX = (this.bounds.x_min + this.bounds.x_max) / 2;
        const centerY = (this.bounds.y_min + this.bounds.y_max) / 2;
        const centerZ = (this.bounds.z_min + this.bounds.z_max) / 2;
        const target = new THREE.Vector3(centerX, centerZ, centerY);
        switch (preset) {
          case 'overview':
            this.camera.position.set(centerX + 20, centerZ + 16, centerY + 20);
            this.controls.target.copy(target); this.followId = null; break;
          case 'side':
            this.camera.position.set(centerX + 25, centerZ + 8, centerY);
            this.controls.target.copy(target); this.followId = null; break;
          case 'top':
            this.camera.position.set(centerX, centerZ + 30, centerY);
            this.controls.target.copy(target); this.followId = null; break;
          case 'follow':
            if (this.followId && this.robots.has(this.followId)) {
              const robotGroup = this.robots.get(this.followId);
              const offset = new THREE.Vector3(5, 4, 8);
              this.camera.position.copy(robotGroup.position).add(offset);
              this.controls.target.copy(robotGroup.position);
            } else if (this.robots.size > 0) {
              const firstRobot = this.robots.values().next().value;
              this.followId = firstRobot.name;
              this.selectRobot(this.followId);
            }
            break;
        }
        this.controls.update();
      }

      play(){
        if (!this.frames.length || this.isPlay) return;
        this.isPlay = true;
        const step = () => {
          if (!this.isPlay) return;
          if (this.cur < this.frames.length - 1) {
            this.cur++; this.updateFrame(true);
            const delay = Math.max(50, 150 / this.speed);
            setTimeout(step, delay);
          } else { this.isPlay = false; }
        };
        step();
      }

      pause(){ this.isPlay = false; }

      reset(){
        this.pause(); this.cur = 0; this.updateFrame(true);
        this.trails.clear();
        this.trailsLines.forEach(line => { this.scene?.remove(line); line.geometry?.dispose(); });
        this.trailsLines.clear();
      }
    }

    window.addEventListener('load', () => {
      window.visualizer = new Visualizer();
    });

    window.debugVis = {
      createTestRobot: () => {
        const v = window.visualizer; if (!v || !v.scene) return;
        const testData = { id:"test_robot", team:"red", x:0, y:0, z:2, hp:75, alive:true, within_bounds:true,
          target_enemy:0, move_action:[0.1,0.0,0.0], aim_action:[1.0,0.0,0.0], fire_action:false };
        const robot = v.createRobotMesh(testData);
        v.scene.add(robot); v.robots.set("test_robot", robot);
        v.updateRobotMesh(robot, testData);
      },
      logScene: () => {
        const v = window.visualizer; if (!v || !v.scene) return;
        console.log('Children:', v.scene.children.length);
        console.log('Robots:', v.robots.size);
        console.log('Current frame:', v.cur);
        console.log('Total frames:', v.frames.length);
      }
    };
  </script>
</body>
</html>
